<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>How to write a fire shader · Indigo</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In this how-to guide, we&#x27;re going to look at one approach to writing a little shader that produces procedural flames. Here&#x27;s one I made earlier:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="How to write a fire shader · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="In this how-to guide, we&#x27;re going to look at one approach to writing a little shader that produces procedural flames. Here&#x27;s one I made earlier:"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="Indigo Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="Indigo Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="siteNavGroupActive"><a href="/docs/guides" target="_self">Guides</a></li><li class=""><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="api/api/indigo.html" target="_self">APIs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Gamedev</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">How To&#x27;s</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/guides">About these guides</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gamedev</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/guides/howto-custom-entity">How to make a custom entity</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/guides/howto-fire-shader">How to write a fire shader</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">How to write a fire shader</h1></header><article><div><span><p>In this how-to guide, we're going to look at one approach to writing a little shader that produces procedural flames. Here's one I made earlier:</p>
<p><img src="/img/howtos/campfire.gif" alt="A pixel art campfire with procedural flames" title="A pixel art campfire with procedural flames"></p>
<p>We're first going to cover a few basic concepts needed for writing shaders in Indigo, then look at Signed Distance Functions, Noise, and finally bring it all together to make our fire effect.</p>
<p>There is a <a href="https://github.com/PurpleKingdomGames/indigo-examples/tree/master/howto/fire">github repo</a> that accompanies this how-to.</p>
<blockquote>
<p>Small apology: I'm using lots of gif animations to show what is going on, and they mostly do not loop cleanly!</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="indigo-shader-need-to-knows"></a><a href="#indigo-shader-need-to-knows" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Indigo shader need-to-know's</h2>
<p>Every game engine implements shaders in a slightly different way. This is because they are trying to bridge the gap between the various platforms they support, and the idiosyncrasies of how that particular engine works. Indigo is the same. Indigo uses <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL 300</a> which is the <a href="https://en.wikipedia.org/wiki/WebGL">WebGL 2.0</a> variation. The main gap Indigo has to bridge is between the Functional world of Scala and the procedural world of WebGL.</p>
<p>If you haven't already, you should go and read the <a href="/docs/guides/howto-custom-entity">&quot;How to make a custom entity&quot;</a> guide first, because this how-to builds on that one. You will indeed need a custom entity to run your shader in, this is the one I'm using:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> indigo._
<span class="hljs-keyword">import</span> indigo.<span class="hljs-type">ShaderPrimitive</span>._

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fire</span>(<span class="hljs-params">
    position: <span class="hljs-type">Point</span>,
    size: <span class="hljs-type">Size</span>,
    depth: <span class="hljs-type">Depth</span>,
    outer: <span class="hljs-type">RGB</span>,
    inner: <span class="hljs-type">RGB</span>,
    center: <span class="hljs-type">RGB</span>,
    offset: <span class="hljs-type">Double</span>
</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">EntityNode</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flip</span></span>: <span class="hljs-type">Flip</span>        = <span class="hljs-type">Flip</span>.<span class="hljs-keyword">default</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ref</span></span>: <span class="hljs-type">Point</span>        = <span class="hljs-type">Point</span>.zero
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotation</span></span>: <span class="hljs-type">Radians</span> = <span class="hljs-type">Radians</span>.zero
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale</span></span>: <span class="hljs-type">Vector2</span>    = <span class="hljs-type">Vector2</span>.one

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withDepth</span></span>(newDepth: <span class="hljs-type">Depth</span>): <span class="hljs-type">Fire</span> =
    <span class="hljs-keyword">this</span>.copy(depth = newDepth)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toShaderData</span></span>: <span class="hljs-type">ShaderData</span> =
    <span class="hljs-type">ShaderData</span>(
      <span class="hljs-type">Fire</span>.shaderId,
      <span class="hljs-type">UniformBlock</span>(
        <span class="hljs-string">"FireData"</span>,
        <span class="hljs-type">List</span>(
          <span class="hljs-type">Uniform</span>(<span class="hljs-string">"OFFSET"</span>)       -&gt; float(offset),
          <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_OUTER"</span>)  -&gt; vec3(outer.r, outer.g, outer.b),
          <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_INNER"</span>)  -&gt; vec3(inner.r, inner.g, inner.b),
          <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_CENTER"</span>) -&gt; vec3(center.r, center.g, center.b)
        )
      )
    )

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Fire</span></span>:

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orange</span></span>(position: <span class="hljs-type">Point</span>, size: <span class="hljs-type">Size</span>): <span class="hljs-type">Fire</span> =
    <span class="hljs-type">Fire</span>(position, size, <span class="hljs-type">Depth</span>(<span class="hljs-number">1</span>), <span class="hljs-type">RGB</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>), <span class="hljs-type">RGB</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.0</span>), <span class="hljs-type">RGB</span>.<span class="hljs-type">White</span>, <span class="hljs-number">0.0</span>d)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">blue</span></span>(position: <span class="hljs-type">Point</span>, size: <span class="hljs-type">Size</span>): <span class="hljs-type">Fire</span> =
    <span class="hljs-type">Fire</span>(position, size, <span class="hljs-type">Depth</span>(<span class="hljs-number">1</span>), <span class="hljs-type">RGB</span>.<span class="hljs-type">Blue</span>, <span class="hljs-type">RGB</span>.<span class="hljs-type">Cyan</span>, <span class="hljs-type">RGB</span>.<span class="hljs-type">White</span>, <span class="hljs-number">0.0</span>d)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">green</span></span>(position: <span class="hljs-type">Point</span>, size: <span class="hljs-type">Size</span>): <span class="hljs-type">Fire</span> =
    <span class="hljs-type">Fire</span>(position, size, <span class="hljs-type">Depth</span>(<span class="hljs-number">1</span>), <span class="hljs-type">RGB</span>.<span class="hljs-type">Green</span>, <span class="hljs-type">RGB</span>.<span class="hljs-type">Yellow</span>, <span class="hljs-type">RGB</span>.<span class="hljs-type">White</span>, <span class="hljs-number">0.0</span>d)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(position: <span class="hljs-type">Point</span>, size: <span class="hljs-type">Size</span>): <span class="hljs-type">Fire</span> =
    orange(position, size)

  <span class="hljs-keyword">val</span> shaderId: <span class="hljs-type">ShaderId</span> =
    <span class="hljs-type">ShaderId</span>(<span class="hljs-string">"fire shader"</span>)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shader</span></span>(fragProgram: <span class="hljs-type">AssetName</span>): <span class="hljs-type">EntityShader</span> =
    <span class="hljs-type">EntityShader</span>
      .<span class="hljs-type">External</span>(<span class="hljs-type">ShaderId</span>(<span class="hljs-string">"fire shader"</span>))
      .withFragmentProgram(fragProgram)
</code></pre>
<p>The <code>Fire</code> case class extends <code>EntityNode</code> meaning that we must supply a few values for it to work, but once we've done that we can add it to our scene. Here I'm using one of the helper functions in the companion object to add an orange fire:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">present</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">Unit</span>], model: <span class="hljs-type">Unit</span>, viewModel: <span class="hljs-type">Unit</span>): <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneUpdateFragment</span>] =
    <span class="hljs-type">Outcome</span>(
      <span class="hljs-type">SceneUpdateFragment</span>(
        <span class="hljs-type">Fire</span>.orange(<span class="hljs-type">Point</span>(<span class="hljs-number">60</span>, <span class="hljs-number">30</span>), <span class="hljs-type">Size</span>(<span class="hljs-number">70</span>, <span class="hljs-number">100</span>))
      )
    )
</code></pre>
<blockquote>
<p>In point of fact, all the screen shots below are set to take up the whole screen: <code>Fire.orange(Point(0, 0), Size(384, 384))</code></p>
</blockquote>
<p>Important things to note about our custom entity:</p>
<ol>
<li>The <code>EntityShader</code> definition in the <code>Fire</code> companion object.</li>
<li>The <code>toShaderData</code> method</li>
</ol>
<p>Taking them in turn:</p>
<h3><a class="anchor" aria-hidden="true" id="the-entityshader"></a><a href="#the-entityshader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>EntityShader</code></h3>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shader</span></span>(fragProgram: <span class="hljs-type">AssetName</span>): <span class="hljs-type">EntityShader</span> =
  <span class="hljs-type">EntityShader</span>
    .<span class="hljs-type">External</span>(<span class="hljs-type">ShaderId</span>(<span class="hljs-string">"my fire shader"</span>))
    .withFragmentProgram(fragProgram)
</code></pre>
<p>In our case, the fragment program is being loaded as a normal <code>AssetType.Text</code>, and by supplying the <code>AssetName</code> to an <code>External</code> entity shader, Indigo will use the contents of the text asset as the shader code.</p>
<p>This shader only uses a custom <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#:~:text=A%20Fragment%20Shader%20is%20the,a%20%22fragment%22%20is%20generated.">fragment shader</a>. The simplest (although I have included our data struct) example of an external fragment shader written in file called <code>shader.frag</code> might be:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-meta">#version 300 es</span>
<span class="hljs-comment">// Above line must be the first thing in the file, and tells WebGL which GLSL version we're using.</span>

<span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>; <span class="hljs-comment">// Declare float precision</span>

<span class="hljs-comment">// Declares a constant we know Indigo provides so that we can use it and the linter can check it.</span>
<span class="hljs-type">vec4</span> COLOR;

<span class="hljs-comment">// Everything outside of this tag is ignored by Indigo!</span>
<span class="hljs-comment">//&lt;indigo-fragment&gt;</span>

<span class="hljs-comment">// A struct that mirrors the data in the `toShaderData` method, this is data sent from Indigo to the shader.</span>
<span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> FireData {
  <span class="hljs-type">float</span> OFFSET;
  <span class="hljs-type">vec3</span> COLOR_OUTER;
  <span class="hljs-type">vec3</span> COLOR_INNER;
  <span class="hljs-type">vec3</span> COLOR_CENTER;
};

<span class="hljs-comment">// The required fragment function setting the COLOR output variable to green.</span>
<span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
<span class="hljs-comment">//&lt;/indigo-fragment&gt;</span>
</code></pre>
<p>The advantage of using an external file is that you can use a nice editor with GLSL syntax highlighting and linting. Everything outside the <code>//&lt;indigo-fragment&gt;</code> tags is ultimately ignored and omitted, but the values are used by GLSL linters to check your code. Any GLSL code you wish to use must be inside the tags.</p>
<p>You <em>MUST</em> remember to register your shader, like this (or under <code>val shader: Set[Shader]</code> in an Indigo sandbox game):</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Assets</span></span>:
  <span class="hljs-keyword">val</span> fireProgram = <span class="hljs-type">AssetName</span>(<span class="hljs-string">"fire"</span>)
  <span class="hljs-keyword">val</span> assets: <span class="hljs-type">Set</span>[<span class="hljs-type">AssetType</span>] =
    <span class="hljs-type">Set</span>(<span class="hljs-type">AssetType</span>.<span class="hljs-type">Text</span>(fireProgram, <span class="hljs-type">AssetPath</span>(<span class="hljs-string">"assets/shader.frag"</span>)))

<span class="hljs-type">BootResult</span>
  .noData(<span class="hljs-type">GameConfig</span>.<span class="hljs-keyword">default</span>.withViewport(<span class="hljs-number">384</span>, <span class="hljs-number">384</span>).withMagnification(<span class="hljs-number">2</span>))
  .withShaders(<span class="hljs-type">Fire</span>.shader(<span class="hljs-type">Assets</span>.fireProgram))
  .withAssets(<span class="hljs-type">Assets</span>.assets)
<span class="hljs-comment">// res0: BootResult[Unit] = BootResult(</span>
<span class="hljs-comment">//   GameConfig(</span>
<span class="hljs-comment">//     GameViewport(Size(384, 384)),</span>
<span class="hljs-comment">//     60,</span>
<span class="hljs-comment">//     RGBA(0.0, 0.0, 0.0, 1.0),</span>
<span class="hljs-comment">//     2,</span>
<span class="hljs-comment">//     AdvancedGameConfig(WebGL2WithFallback, false, 256, false, false, true)</span>
<span class="hljs-comment">//   ),</span>
<span class="hljs-comment">//   (),</span>
<span class="hljs-comment">//   Set(),</span>
<span class="hljs-comment">//   Set(Text("fire", "assets/shader.frag")),</span>
<span class="hljs-comment">//   Set(),</span>
<span class="hljs-comment">//   Set(),</span>
<span class="hljs-comment">//   Set(External("fire shader", None, Some("fire"), None, None, None))</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="the-toshaderdata-method"></a><a href="#the-toshaderdata-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>toShaderData</code> method</h3>
<p>Eventually we're going to need to tell our custom entity which shader to use (<code>Fire.shaderId</code>) and also supply values to the shader to change how it behaves. This is the final version, we're skipping to the end, but hopefully it should be fairly self explanatory:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> offset = <span class="hljs-number">0.0</span>d <span class="hljs-comment">// Used to make different instances flicker out of sync</span>
<span class="hljs-comment">// offset: Double = 0.0 // Used to make different instances flicker out of sync</span>
<span class="hljs-keyword">val</span> center = <span class="hljs-type">RGB</span>.<span class="hljs-type">White</span>
<span class="hljs-comment">// center: RGB = RGB(1.0, 1.0, 1.0)</span>
<span class="hljs-keyword">val</span> inner = <span class="hljs-type">RGB</span>.<span class="hljs-type">Yellow</span>
<span class="hljs-comment">// inner: RGB = RGB(1.0, 1.0, 0.0)</span>
<span class="hljs-keyword">val</span> outer = <span class="hljs-type">RGB</span>.<span class="hljs-type">Red</span>.mix(<span class="hljs-type">RGB</span>.<span class="hljs-type">Yellow</span>, <span class="hljs-number">0.5</span>)
<span class="hljs-comment">// outer: RGB = RGB(1.0, 0.5, 0.0)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toShaderData</span></span>: <span class="hljs-type">ShaderData</span> =
  <span class="hljs-type">ShaderData</span>(
    <span class="hljs-type">Fire</span>.shaderId,
    <span class="hljs-type">UniformBlock</span>(
      <span class="hljs-string">"FireData"</span>,
      <span class="hljs-type">List</span>(
        <span class="hljs-type">Uniform</span>(<span class="hljs-string">"OFFSET"</span>)       -&gt; float(offset),
        <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_OUTER"</span>)  -&gt; vec3(outer.r, outer.g, outer.b),
        <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_INNER"</span>)  -&gt; vec3(inner.r, inner.g, inner.b),
        <span class="hljs-type">Uniform</span>(<span class="hljs-string">"COLOR_CENTER"</span>) -&gt; vec3(center.r, center.g, center.b)
      )
    )
  )
</code></pre>
<p>The main thing to note is that the <code>UniformBlock</code> aligns exactly to the struct found in the shader:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> FireData {
  <span class="hljs-type">float</span> OFFSET;
  <span class="hljs-type">vec3</span> COLOR_OUTER;
  <span class="hljs-type">vec3</span> COLOR_INNER;
  <span class="hljs-type">vec3</span> COLOR_CENTER;
};
</code></pre>
<p>At some point in the future it would be good to improve the type safety around the relationship across this interface, but for now, please take care. More information on how this works including the <strong>all important packing rules</strong> can be found in the <a href="/docs/shaders/shader-overview">Shaders Overview</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="uvs"></a><a href="#uvs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UVs</h3>
<p>UV coordinates tell WebGL how to map a texture onto a mesh / 3d model.</p>
<p>The important thing to remember is that all coordinate systems in Indigo go from top left to bottom right, and shader UVs are no exception. This will be super important when we look at SDFs.</p>
<p><img src="/img/howtos/shader_uvs.png" alt="Shader UV coords in Indigo are 0,0 top left to 1,1 bottom right" title="Shader UV coords in Indigo are 0,0 top left to 1,1 bottom right"></p>
<h2><a class="anchor" aria-hidden="true" id="flint--tinder"></a><a href="#flint--tinder" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Flint &amp; Tinder</h2>
<p>To make a fire shader, we need a couple of raw materials:</p>
<ol>
<li>A way to draw a basic shape, in our case a circle.</li>
<li>A way to distort that shape into an animated flame.</li>
</ol>
<p>For this, we're going to use an SDF and Noise respectively.</p>
<h3><a class="anchor" aria-hidden="true" id="signed-distance-functions-sdfs"></a><a href="#signed-distance-functions-sdfs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signed Distance Functions (SDFs)</h3>
<p>An SDF, or Signed Distance Function, is simply a function that, for a given point (UV coordinate) returns the distance to the edge of a shape. Therefore, a distance of 0 means you are on the shape's border, a distance greater than 0 is outside the shape, and less than 0 is inside the shape.</p>
<p><em>The SDF for a circle might be the simplest SDF there is, so it's a good one to use to get the grips with the concept. Why not try a few values manually to get a feel for it?</em></p>
<blockquote>
<p><strong>It is important to note</strong> that SDFs work in &quot;world space&quot;, that is, around the origin coordinate (0,0).</p>
</blockquote>
<p>Here's the function we're going to use:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">float</span> sdfCircle(<span class="hljs-type">vec2</span> p, <span class="hljs-type">float</span> r) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">length</span>(p) - r;
}
</code></pre>
<p>Recall that our UVs are (0,0) top-left to (1,1) bottom-right, so when we call this function we must move our <code>vec2 p</code> back to the origin by subtracting 0.5, and supply a radius <code>r</code> between 0 and 0.5, like this:</p>
<pre><code class="hljs css language-glsl">sdfCircle(UV - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>)
</code></pre>
<p>The function returns a float, and if we plumb it into our <code>COLOR</code> output like this:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  <span class="hljs-type">float</span> sdf = sdfCircle(UV - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>);
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(<span class="hljs-built_in">abs</span>(sdf)), <span class="hljs-number">1.0</span>);
}
</code></pre>
<blockquote>
<p>Note the use of <code>abs()</code> - inside the circle is a negative number, but there's no such thing as a -1.0 red color value!</p>
</blockquote>
<p>We get:</p>
<p><img src="/img/howtos/sdf.png" alt="The SDF of a circle drawn literally" title="The SDF of a circle drawn literally"></p>
<p>Not bad but we need a hard edged circle, so we will employ a function called <code>step()</code>. <code>step()</code> acts as a logic gate, it takes an input value and a boundary value. If the input is less than the boundary then it returns 1, else 0.</p>
<p>Conveniently, our SDF is less than 0 inside the circle! So if we change our function to:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  <span class="hljs-type">float</span> sdf = sdfCircle(UV - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>);
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">step</span>(sdf, <span class="hljs-number">0.0</span>));
}
</code></pre>
<p>We get:</p>
<p><img src="/img/howtos/sdf-circle.png" alt="A Circle drawn using an SDF" title="A Circle drawn using an SDF"></p>
<p>Perfect! Now for a bit of randomness...</p>
<h3><a class="anchor" aria-hidden="true" id="noise"></a><a href="#noise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Noise</h3>
<p>It may come as a surprise, but GLSL does not include a noise function. For speed, we're going to borrow <a href="https://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm">this one</a> which is a form of <a href="https://en.wikipedia.org/wiki/Perlin_noise">perlin noise</a>.</p>
<p>What we need is for our noise to be moving upwards to simulate rising heat. So we call our function as follows:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  <span class="hljs-type">float</span> octaves = <span class="hljs-number">8.0</span>;
  <span class="hljs-type">float</span> noise = calcNoise(octaves * UV + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, TIME)).x;
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(noise), <span class="hljs-number">1.0</span>);
}
</code></pre>
<p>When you use gradient noise you need to specify the complexity, which I'm (possibly wrongly!) referring to as &quot;octaves&quot; above. To animate the noise, we add the <code>TIME</code> variable to the <code>y</code> component of the UV <code>vec2</code>. Then ultimately we use the <code>x</code> component value of the <code>vec4</code> returned by the noise calculation, as this is the noise amount. (<code>yzw</code> are the derivatives.)</p>
<blockquote>
<p>Note: <code>TIME</code> is an ever increasing value! We're using it rather naively here and it may create weird looking results eventually. A better solution may be to loop time to a known good range.</p>
</blockquote>
<p>This gives us animated noise. Doesn't look very fluid-like yet, but it's all we need.</p>
<p><img src="/img/howtos/animated-noise.gif" alt="Noise move up on the Y-axis" title="Noise move up on the Y-axis"></p>
<h2><a class="anchor" aria-hidden="true" id="making-fire"></a><a href="#making-fire" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making fire</h2>
<p>If we crudely overlay the two components we have so far as a reminder of what we've done, we see the following:</p>
<p><img src="/img/howtos/animated-noise-circle.gif" alt="A circle overlaid onto animated noise" title="A circle overlaid onto animated noise"></p>
<p>Our next challenge is to find a way to combine the SDF circle with the noise. Recall that the SDF calculation makes use of a point <code>p</code> to decide if the we're inside or outside the circle. Our approach in essence will be to move point <code>p</code> by the noise amount.</p>
<p>Here is an exciting first attempt!</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  <span class="hljs-type">float</span> octaves = <span class="hljs-number">8.0</span>;
  <span class="hljs-type">float</span> noise = calcNoise(<span class="hljs-type">vec2</span>(octaves * UV.x, octaves * UV.y + TIME)).x;
  <span class="hljs-type">float</span> sdf = sdfCircle((UV - <span class="hljs-number">0.5</span>) * (noise * <span class="hljs-number">5.0</span>), <span class="hljs-number">0.25</span>);
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">step</span>(sdf, <span class="hljs-number">0.0</span>));
}
</code></pre>
<blockquote>
<p>Note that the 5.0 in <code>(noise * 5.0)</code> is a bit of a magic number. There are a few of those in the final code that I tinkered with, justified on the basis of being aesthetically pleasing. In terms of business logic and domain modeling I'd normally find that rather uncomfortable, but let us not forget that we're making <strong><em>art</em></strong> here! Sometimes you just have to go with what (you think) looks good!</p>
</blockquote>
<p><img src="/img/howtos/animated-noise-circle2.gif" alt="An sdf deformed uniformly by noise" title="An sdf deformed uniformly by noise"></p>
<p>At first glance it looks like some sort of 80s fashion accident. On closer inspection there is a glob of white nearer the center... so maybe we just need to be more selective about how we move the point <code>p</code>?</p>
<p>If you can imagine a candle or torch flame, the deformation of the flame is not uniform. There is very little movement on the X-Axis (assuming no wind!), and similarly very little movement on the Y-Axis at the base of the flame. All the real movement happens at the top. How might we account for that?</p>
<p>Well the X-Axis is simple enough, we just need to multiply the amount of deformation by a small number, we'll use <code>0.1</code>, i.e. a maximum of 10% wobble.</p>
<p>The Y-Axis is slight more tricky because we want to describe an area of effect, with the most movement happening in the top half of the shader. To do that, we're going to construct a gradient based on the UV values, like so:</p>
<p><code>float yGradient = clamp(0.7 - UV.y, 0.0, 1.0) * 0.6;</code></p>
<p>Drawn out, this looks as follows:</p>
<p><img src="/img/howtos/gradient.png" alt="A gradient describing an area of effect" title="A gradient describing an area of effect"></p>
<blockquote>
<p>Figuring out how to draw the values your producing so that you can make sense of them is the equivalent of &quot;print statement&quot; debugging in shaders!</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="putting-it-all-together"></a><a href="#putting-it-all-together" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Putting it all together</h3>
<p>If we take our previous code and combine it with the gradient and fixed values to dampen the movement, our code looks like this:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  <span class="hljs-type">float</span> octaves = <span class="hljs-number">8.0</span>;
  <span class="hljs-type">float</span> noiseAmount = calcNoise(<span class="hljs-type">vec2</span>(octaves * UV.x, octaves * UV.y + TIME)).x;
  <span class="hljs-type">float</span> yGradient = <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0.7</span> - UV.y, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>) * <span class="hljs-number">0.6</span>;
  <span class="hljs-type">vec2</span> sdfNoise = <span class="hljs-type">vec2</span>(noiseAmount * <span class="hljs-number">0.1</span>, noiseAmount * <span class="hljs-number">2.5</span> * yGradient);
  <span class="hljs-type">vec2</span> p = (UV - <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>)) + sdfNoise;

  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">step</span>(sdfCircle(p, <span class="hljs-number">0.25</span>), <span class="hljs-number">0.0</span>));
}
</code></pre>
<p><em>Note again a couple of magic numbers to make it look nicer! For example, I've moved the flame down the y-axis a bit by using <code>UV - vec2(0.5, 0.7)</code> instead of <code>UV - 0.5</code>.</em></p>
<p><img src="/img/howtos/slow-flame.gif" alt="A very slow black and white flame" title="A very slow black and white flame"></p>
<p>It's very slow, but that's basically our flame! All we have to do is speed up time by multiplying the <code>TIME</code> variable and we're nearly there.</p>
<p>We do need to fix the colour though, and to do that we're just going to draw several SDF circles one on top of the other, with a bit of repositioning.</p>
<p><img src="/img/howtos/flame-colors.png" alt="Three SDF circles to create the flame colours" title="Three SDF circles to create the flame colours"></p>
<p>Put it all together and you get:</p>
<p><img src="/img/howtos/flame.gif" alt="A procedural flame!" title="A procedural flame!"></p>
<p>Notice that the three colors move in sync. This is because they are all using the same underlying noise value and means that, for example, you could never be in a situation where the yellow fully escaped the orange.</p>
<p>..and if we use our <code>Fire</code> entity's constructor to supply different values to the shader...</p>
<p><img src="/img/howtos/flames.gif" alt="Three different color procedural flames!" title="Three different color procedural flames!"></p>
<blockquote>
<p>You may notice that the aspect ratio of the flames in the second animation is different. The UV coordinates (0,0) to (1,1) respect the scale, rotation and aspect ratio of the space on the screen described by the custom entity. So if you make a square space you get a round flame because the SDF makes a circle, but if you give it a width half the value of the height, the SDF becomes a tall ellipse and the result is a narrow flame.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="wrapping-up"></a><a href="#wrapping-up" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping up</h2>
<p>I hope you found that interesting and that you are feeling inspired to create some shader effects of your own. Don't forget to visit us on <a href="https://discord.gg/b5CD47g">Discord</a> to get help and show off your creations!</p>
<h2><a class="anchor" aria-hidden="true" id="finding-out-more-about-shaders"></a><a href="#finding-out-more-about-shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Finding out more about shaders</h2>
<p>There are endless shader tutorials out there and this one barely scratches the surface, but the shader source code in the <a href="https://github.com/PurpleKingdomGames/indigo-examples/tree/master/howto/fire">github repo</a> makes reference to two sections of code shamelessly borrowed from master of shaders, <a href="https://twitter.com/iquilezles">Inigo Quilez</a>:</p>
<ol>
<li><a href="https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm">SDF circle</a></li>
<li><a href="https://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm">Gradiant noise</a></li>
</ol>
<p>Inigo Quilez also has a <a href="https://www.youtube.com/channel/UCdmAhiG8HQDlz8uyekw4ENw">YouTube channel</a> where he attempts to explain all this mathematical magic!</p>
<p>Here is some of his work. If you liked drawing with SDF's and noise, <a href="https://www.youtube.com/watch?v=s_UOFo2IULQ">check this out!</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/guides/howto-custom-entity"><span class="arrow-prev">← </span><span>How to make a custom entity</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#indigo-shader-need-to-knows">Indigo shader need-to-know's</a><ul class="toc-headings"><li><a href="#the-entityshader">The <code>EntityShader</code></a></li><li><a href="#the-toshaderdata-method">The <code>toShaderData</code> method</a></li><li><a href="#uvs">UVs</a></li></ul></li><li><a href="#flint--tinder">Flint &amp; Tinder</a><ul class="toc-headings"><li><a href="#signed-distance-functions-sdfs">Signed Distance Functions (SDFs)</a></li><li><a href="#noise">Noise</a></li></ul></li><li><a href="#making-fire">Making fire</a><ul class="toc-headings"><li><a href="#putting-it-all-together">Putting it all together</a></li></ul></li><li><a href="#wrapping-up">Wrapping up</a></li><li><a href="#finding-out-more-about-shaders">Finding out more about shaders</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a><a href="/docs/en/quickstart/project-templates">Project templates</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://github.com/PurpleKingdomGames/indigo/discussions">GitHub Discussons</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section><section class="copyright">Copyright © 2021 Purple Kingdom Games Limited</section></footer></div></body></html>