[
{
	"uri": "https://tyrian.indigoengine.io/installation/",
	"title": "Setup &amp; Configuration",
	"tags": [],
	"description": "",
	"content": "Quick Setup with Giter8 You can create an sbt based Tyrian project and have it up and running in less than 5 minutes!*\nFrom your command line, create a folder for your project, navigate into it, and run:\nsbt new PurpleKingdomGames/tyrian.g8 Then follow the instructions in the README file.\n(* Probably, if you have sbt and npm/yarn already installed\u0026hellip; ðŸ˜…)\nInstallation Tyrian is a Scala 3 Web UI library, so please set your Scala version to 3.2.1 or higher.\nYou can use Tyrian with Scala 2 thanks to cross versions and the magic of TASTy.\nPlease note that both the sbt and Mill instructions below assume you intend to work with some sort of web packager/bundler, and therefore emit common js modules.\nThe examples in the Tyrian repo almost all use Parcel.js as the bundler.\nsbt Add the Scala.js plugin to your project/plugins.sbt file.\naddSbtPlugin(\u0026#34;org.scala-js\u0026#34; % \u0026#34;sbt-scalajs\u0026#34; % \u0026#34;1.13.0\u0026#34;) Enable the plugin and add the Tyrian library to your build.sbt file.\nAt the time of writing, only an implementation for Cats Effect 3\u0026rsquo;s IO exists, only because no other compatible libs were available. In theory however, Tyrian will support any effectful monad that implements the CE3 typeclasses. If you\u0026rsquo;d like to do that, take a look at the tiny implementation, and import tyrian instead of tyrian-io shown below.\nenablePlugins(ScalaJSPlugin) libraryDependencies ++= Seq( \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian-io\u0026#34; % \u0026#34;0.6.1\u0026#34; ) scalaJSLinkerConfig ~= { _.withModuleKind(ModuleKind.CommonJSModule) } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\nlibraryDependencies ++= Seq( ... \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian-indigo-bridge\u0026#34; % \u0026#34;0.6.1\u0026#34; ) Mill Below is a complete, basic Mill build.sc file including MUnit for testing.\nimport $ivy.`com.lihaoyi::mill-contrib-bloop:$MILL_VERSION` import mill._ import mill.scalalib._ import mill.scalajslib._ import mill.scalajslib.api._ object counter extends ScalaJSModule { def scalaVersion = \u0026#34;3.2.1\u0026#34; def scalaJSVersion = \u0026#34;1.13.0\u0026#34; def ivyDeps = Agg(ivy\u0026#34;io.indigoengine::tyrian::0.6.1\u0026#34;) override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) object test extends Tests { def ivyDeps = Agg(ivy\u0026#34;org.scalameta::munit::0.7.29\u0026#34;) def testFramework = \u0026#34;munit.Framework\u0026#34; override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def jsEnvConfig = T( JsEnvConfig.NodeJs(args = List(\u0026#34;--dns-result-order=ipv4first\u0026#34;)) ) } } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\ndef ivyDeps = Agg( ivy\u0026#34;io.indigoengine::tyrian::0.6.1\u0026#34;, ivy\u0026#34;io.indigoengine::tyrian-indigo-bridge::0.6.1\u0026#34; ) "
},
{
	"uri": "https://tyrian.indigoengine.io/architecture/",
	"title": "Architecture &amp; Patterns",
	"tags": [],
	"description": "",
	"content": "The Elm Architecture Tyrian provides a runtime environment for executing applications that was originally designed according to the Elm architecture.\nElm is the name of a language and an ecosystem, but it\u0026rsquo;s architecture has become more widely known as the \u0026lsquo;TEA Pattern\u0026rsquo; ((T)he (E)lm (A)rchitecture) and has influenced many GUI/UI libraries and implementations beyond the world of functional programming.\nThe TEA pattern The TEA Pattern is about:\nImmutable data. Pure functions. Uni-directional data flow. Strictly ordered events and updates. This gives you a system that is very easy it reason about, since the data cannot (or is unlikely to) be subject to hard-to-test race conditions or side effects, and everything happens in a predictable order.\nThe purity of the system, the way that the state is held apart from the processing and rendering functions, also allows for easy testing without the need for complex mocking.\nIn essence:\nThe state of the application is modeled by an immutable Model. Events that change the state of the application are modeled by an immutable Msg type. State transitions are implemented by a (Msg, Model) =\u0026gt; Model function. Finally, a Model =\u0026gt; Html[Msg] function defines how to render the state of the application in HTML. Tyrian vs Elm As you might expect, Elm is a far richer offering that Tyrian is now, and in all likelihood ever will be. It\u0026rsquo;s been around a lot longer, and there are a lot more people working on and with Elm every day feeding into it\u0026rsquo;s design.\nHaving said that: While Elm\u0026rsquo;s architecture has taken on a life of it\u0026rsquo;s own and influenced the state of the art of functional (and even non-FP!) UI programming, Elm itself has remained somewhat niche.\nPeople tend to love Elm \u0026hellip;or hate it. A lot of that reaction can be attributed to the fact that Elm is a very opinionated language, and you either like that or you do not.\nWhat Elm\u0026rsquo;s opinionated stance buys you is an ecosystem where if your code compiles, it works! And that is an amazing thing! In the cost/benefit analysis: The benefit is an incredibly robust web development experience, at the cost of literally not being able to do anything that is not permitted (because it would break the robustness guarantees of the ecosystem).\nTyrian takes the glorious essence of Elm\u0026rsquo;s architecture, but removes almost all of the opinions \u0026hellip;and with it of course, almost all of the safety nets!\nWant to break up your code into lots of files and classes? Carry on. Want to use refined types? Ok then. Want to use Typeclasses? No problem. Want to bring in a heavyweight FP library? Sure thing. Want to talk to JavaScript directly over an FFI? Go nuts. Want to do a non-exhaustive match? I mean, you can but\u0026hellip; Want to throw a massive exception? \u0026hellip;erm \u0026hellip;sure\u0026hellip; Be safe out there folks! ðŸ˜€\nTyrian \u0026amp; Indigo Tyrian and Indigo are siblings and both follow an interpretation of the TEA Pattern, but they grew up at different times under different influences, and so they are not exactly the same in their design.\nTyrian is designed in the same image as Elm, and for the same purpose: Building rich web apps. Indigo however is a game engine. They do have a lot of things in common:\nThe APIs are all pure functions The state is immutable The data follows a uni-directional path Events/Messages are strictly ordered \u0026hellip;even the names and signatures of the API functions are similar \u0026hellip;and so on.\nBut if you consider the life of a GUI app versus a game - in general - user interfaces don\u0026rsquo;t do anything except as a reaction to user input. Yes, there are exceptions, you can do animations, people do use Elm to make games, etc. But as a broad brush principle, most of the time your word processor or photo editing applications are doing nothing unless you are doing something with them. Hammering keys and painting with you mouse.\nGames on the other hand are normally doing things all the time. Even if the player isn\u0026rsquo;t doing anything! There will be background animations, particle effects will be firing, non-player characters will be walking around, your character will get bored and start impatiently tapping their foot.\nTwo of the main ways this difference visibly manifests itself are:\nCmd vs Outcome The nature of your Model instance Cmd vs Outcome The update function in Tyrian returns a (Model, Cmd) where the command is a lazily evaluated task - perhaps an HTTP call or some other side effect. Whereas in Indigo you return an Outcome, but an outcome does not allow you to directly describe actions that would need evaluation, it only captures updated values and events. If you want to make an HTTP call, there\u0026rsquo;s an event for that.\nIn Tyrian we expect that you\u0026rsquo;ll be doing a lot of out-of-band/concurrent/side-effecting work like calling web services and interacting with JavaScript, in Indigo we assume you mostly won\u0026rsquo;t be.\nThis has the interesting side effect that Tyrian\u0026rsquo;s update functions are referentially transparent, but Indigo\u0026rsquo;s are both referentially transparent and declarative. The former allows you to do more practical things, the latter is lighter and easier to test, but less clean if you do need to, say, call down to JavaScript.\nThe nature of your Model What is in your model?\nIn a GUI app, your model is probably quite close to representing the things that will be displayed. Perhaps it holds the current state of a quiz or survey for example, or the items in a todo list.\nIn an Indigo game, the model tends to be much more abstract and divorced from any presentation concerns. So much so that Indigo has an extra model called a ViewModel that behaves more like a model in Tyrian.\nAs an example: Consider the score counter on a pinball machine. What makes these fun is that they do not simply show your score, they rapidly roll through the numbers always trying to keep up with your score!\nWe have two things we have to know to draw this effect:\nThe real score the player has achieved. The score currently being shown. In Tyrian, both of these values would be held in the Model. In Indigo, the real score (1) would be held in the Model as it\u0026rsquo;s a factual piece of data, while the currently displayed score would live in the ViewModel since it\u0026rsquo;s purely there for presentation purposes.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/",
	"title": "Core Concepts",
	"tags": [],
	"description": "",
	"content": "Core Concepts This section covers the key features and functions of Tyrian.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples We have a number of examples to help you get started with Tyrian, instructions on how to run them can be found in the README file under the examples folder in the repo.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/information/",
	"title": "Information &amp; Trivia",
	"tags": [],
	"description": "",
	"content": "Discussion If you\u0026rsquo;re new to the territory, we highly recommend this thoughtful blog post by Laminar\u0026rsquo;s author, Nikita Gazarov.\nThere is a point in that post where Nikita says the following:\n(..) and having now walked the path myself I finally understood exactly what that reason was: functional reactive programming (FRP) and virtual DOM don\u0026rsquo;t mix!\nVirtual DOM and FRP solve the exact same problem â€“ efficiently keeping the rendered DOM in sync with application state â€“ but they approach it from entirely opposite directions (..)\nQuite right too. It\u0026rsquo;s an important fork in the road. One direction takes you to FRP and Laminar, the other to Virtual DOM like Tyrian and Elm. Both are equally valid choices with quite subtle trade-offs.\nBroadly the argument for FRP is speed, as updates are minimal and precise. The argument for Virtual DOM is that it\u0026rsquo;s easier to test and reason about.\nHowever, You don\u0026rsquo;t have to look hard to find counter arguments to both positions: Elm is blazing fast, and Laminar has solved the classic diamond problem. \u0026hellip;but that\u0026rsquo;s the general argument.\nIn the end, it\u0026rsquo;s mostly personal preference.\nProvenance, and a note of thanks Tyrian was originally a fork of Scalm by Julien Richard-Foy.\nScalm was the Scala.js library I\u0026rsquo;d been looking for but found too late - and it\u0026rsquo;s great fun! In my opinion it was simply ahead of its time, and alas the original authors and contributors had moved on to pastures new long before it was brought to my attention.\nScalm was forked and re-released under a new name and license (with the original authors blessing), partly because I wanted to take it in my own direction without corrupting the original work, and partly \u0026hellip;because I just wasn\u0026rsquo;t sure how to pronounce Scalm! (I did ask.)\nScalm/Tyrian and Indigo (which I also look after) are kindred spirits, in that they both follow the TEA pattern (The Elm Architecture), which is the only frontend architecture pattern I\u0026rsquo;m interested in these days.\nI hope to use Tyrian to complement Indigo, and so have brought it in under the same organisation.\nTyrian is Scalm with the cobwebs blown off. All it\u0026rsquo;s libraries are up to date, I\u0026rsquo;ve started expanding the API, and it will only ever be released against Scala 3 (and beyond!).\nWith huge thanks to the original authors,\nDave, 5th June 2021\n\u0026ldquo;Tyrian\u0026rdquo; Purple \u0026ldquo;It took tens of thousands of desiccated hypobranchial glands, wrenched from the calcified coils of spiny murex sea snails before being dried and boiled, to colour even a single small swatch of fabric, whose fibres, long after staining, retained the stench of the invertebrate\u0026rsquo;s marine excretions. Unlike other textile colours, whose lustre faded rapidly, Tyrian purple \u0026hellip; only intensified with weathering and wear â€“ a miraculous quality that commanded an exorbitant price, exceeding the pigment\u0026rsquo;s weight in precious metals.\u0026rdquo; ~ BBC\nSo it\u0026rsquo;s a purple dye that smells of where it came from and gets richer over time with use. Perfect.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/guided-tour/",
	"title": "A Guided Example",
	"tags": [],
	"description": "",
	"content": "The normal use case for Tyrian is to build a Single Page App/Application (SPA). You can also use Tyrian for Server-side Rendering (SSR), but this page will focus on SPAs.\nA guided example Let\u0026rsquo;s walk through an example to see what goes into a Tyrian App.\nThe \u0026lsquo;counter\u0026rsquo; is a very common example you\u0026rsquo;ll come across for many frameworks, it\u0026rsquo;s a handy Rosetta stone for when you need to orientate yourself in a new framework quickly.\nThe example is comprised of two buttons, + and -, and some text that shows a count that goes up and dow when you press the buttons.\nCounter Code The version of this in the examples is already quite lean, but the version below has been stripped back to the minimum.\nimport tyrian.Html.* import tyrian.* import cats.effect.IO import scala.scalajs.js.annotation.* // @JSExportTopLevel(\u0026#34;TyrianApp\u0026#34;) // Commented out to appease mdoc.. object Main extends TyrianApp[Msg, Model]: def init(flags: Map[String, String]): (Model, Cmd[IO, Msg]) = (0, Cmd.None) def update(model: Model): Msg =\u0026gt; (Model, Cmd[IO, Msg]) = case Msg.Increment =\u0026gt; (model + 1, Cmd.None) case Msg.Decrement =\u0026gt; (model - 1, Cmd.None) def view(model: Model): Html[Msg] = div()( button(onClick(Msg.Decrement))(\u0026#34;-\u0026#34;), div()(model.toString), button(onClick(Msg.Increment))(\u0026#34;+\u0026#34;) ) def subscriptions(model: Model): Sub[IO, Msg] = Sub.None type Model = Int enum Msg: case Increment, Decrement Lets go through it\u0026hellip;\nTyrianApp Starting at the top, we have the most common imports that bring in all the basics you\u0026rsquo;ll need to build your SPA.\nAll Tyrian SPAs must extend TyrianApp which is parameterized by a message type and a model type. These types can be anything you like, but typically Msg is an enum or ADT, and Model is probably a case class (in our case we\u0026rsquo;re just using an Int, but we\u0026rsquo;ll come back to that).\nExtending TyrianApp[Msg, Model] will produce helpful compile errors that will tell you all the functions you need to implement, i.e. init, update, view and subscriptions.\nThe other thing you must do is export the app using Scala.js\u0026rsquo;s @JSExportTopLevel(\u0026quot;TyrianApp\u0026quot;). You can call it anything you like, but all the examples expect the name \u0026ldquo;TyrianApp\u0026rdquo;.\nThe model type Model = Int Our app is a counter, so we need a number we can increment and decrement. In this super simple example, an Int is all that we need for our whole model. Normally you\u0026rsquo;d probably have a case class or something instead. To make it fit nicely, we\u0026rsquo;ve allocated our Int to a Model type alias.\nThe version in the examples uses an opaque type, but here we\u0026rsquo;ve reduced it to a type alias.\nTo use our model, we\u0026rsquo;re going to have to initialize it!\nimport tyrian.* import tyrian.Html.* import cats.effect.IO type Model = Int def init(flags: Map[String, String]): (Model, Cmd[IO, Msg]) = (0, Cmd.None) There\u0026rsquo;s a few things going on here, the only bit we really care about here is the 0 because that is going to be the starting value of our \u0026lsquo;model\u0026rsquo;.\nSome of the other things you can see here:\nflags - Flags can be passed into the app at launch time, think of them like command line arguments. Cmd[IO, Msg] - Commands aren\u0026rsquo;t used in the example, but they allow you to capture and run side effects and emit resulting events. They are a requirement for the function signature, and here we satisfy that with Cmd.None. Rendering the page Let\u0026rsquo;s draw the page. All the functions in Tyrian are encouraged to be pure, which means they operate solely on their arguments to produce a value.\nThe view takes the latest immutable (read-only) model, and produces some HTML in the form of Html[Msg].\ndef view(model: Model): Html[Msg] = div( button(\u0026#34;-\u0026#34;), div(model.toString), button(\u0026#34;+\u0026#34;) ) Here we make a div, add a - button, the another div containing the count (i.e. the model) as plain text, and finally another + button. If you\u0026rsquo;re familiar with HTML this should all look pretty familiar.\nIf you wanted to add an id attribute to the div, you would do so like this:\ndef view(model: Model): Html[Msg] = div(id := \u0026#34;my container\u0026#34;)( button(\u0026#34;-\u0026#34;), div(model.toString), button(\u0026#34;+\u0026#34;) ) Of course a button isn\u0026rsquo;t much use unless it does something, and what we can do is emit an event, called a message, when the button is clicked. For that we need to declare our message type which we\u0026rsquo;ll do as a simple enum that represents the two actions we want to perform:\nenum Msg: case Increment, Decrement \u0026hellip;and add our click events:\ndef view(model: Model): Html[Msg] = div( button(onClick(Msg.Decrement))(\u0026#34;-\u0026#34;), div(model.toString), button(onClick(Msg.Increment))(\u0026#34;+\u0026#34;) ) Note the return type of view is Html[Msg]. This is because unlike normal JavaScript, the onClick is not directly instigating a normal callback, the HTML elements are mapped through and produce messages as values that are passed back to Tyrian.\nUpdating the counter\u0026rsquo;s value The final thing we need to do is react to the messages the view is sending, as follows:\ndef update(model: Model): Msg =\u0026gt; (Model, Cmd[IO, Msg]) = case Msg.Increment =\u0026gt; (model + 1, Cmd.None) case Msg.Decrement =\u0026gt; (model - 1, Cmd.None) Recall that our \u0026lsquo;model\u0026rsquo; is just a type alias for an Int, so all we do is match on the Msg enum type, and either increment or decrement the model - done!\nSubscriptions Subscriptions are part of the standard requirements, but this example doesn\u0026rsquo;t use them for anything. They allow you to \u0026ldquo;subscribe\u0026rdquo; to processes that emit events over time.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/bundling/",
	"title": "Building &amp; Bundling",
	"tags": [],
	"description": "",
	"content": "The JavaScript community don\u0026rsquo;t like to use the word \u0026lsquo;compiler\u0026rsquo;, but tools that gather, parse, and link source files into deployable \u0026lsquo;bundles\u0026rsquo; are an essential part of modern web app development.\nThese tools are called \u0026lsquo;bundlers\u0026rsquo;, the most well known of which is probably Webpack. It is beyond the scope of these docs to explain how bundlers work, but they are well documented tools.\nTyrian needs bundlers too. We could probably manage without them for our raw app, but sooner or later we\u0026rsquo;re bound to need images, and style sheets, and font files, and other JS libraries etc., and that\u0026rsquo;s where bundlers shine.\nBundlers also give you access to things like dev-servers that feature hot-reloading (i.e. your website refreshes when you re-compile your Tyrian app) which is great during development.\nBundler differences Parcel.js Most of our examples use Parcel.js. This is because Webpack is very config heavy, while Parcel is almost zero config. In practical terms this means that Parcel is very quick to get up and running, but if you find a corner case then sourcing a workaround can be tricky. Webpack on the other hand looks to have configuration and plugins for pretty much anything you can think of, and an increased learning curve to go with it.\nscalajs-bundler I\u0026rsquo;ve already mentioned that Webpack is the most well known bundler, and Scala.js has an sbt based bundler called scalajs-bundler that uses Webpack under the covers.\nWe have a standalone example of using Tyrian with scalajs-bundler you can look at, and we also use it in our server based example.\nConverting from Parcel.js to scalajs-bundler In the parcel.js examples, you always call TyrianApp.launch(..) sooner or later. With scalajs-bundler (at least in our examples), the app launches itself. There are a few subtle differences you need to look out for:\nIn your build.sbt file, you need to tell Scala.js to run from the main method. scalaJSUseMainModuleInitializer := true,\n\u0026hellip;and so you\u0026rsquo;ll need a main method! To do that we just call one of the underlying launch methods on the TyrianApp trait. (These are the same methods we would have called from JavaScript to launch the app via Parcel.js.)\ndef main(args: Array[String]): Unit = launch(\u0026#34;myapp\u0026#34;) Add the scalajs-bundler plugin. Add the following to project/plugins.sbt:\naddSbtPlugin(\u0026#34;ch.epfl.scala\u0026#34; % \u0026#34;sbt-scalajs-bundler\u0026#34; % \u0026#34;0.20.0\u0026#34;) And enable the plugin on the project in your build.sbt file:\nenablePlugins(ScalaJSBundlerPlugin) Reference the right js file. In the parcel.js examples, you\u0026rsquo;ll see that we directly reference the normal Scala.js build output file in the target directory (or out directory in Mill examples), such as target/3.2.1/tyrianapp-fastopt.js. This is so that you can hot-reload on re-compile. However in scalajs-bundler, the output folder and file name you need to use will be slightly different, such as target/3.2.1/scalajs-bundler/main/tyrianapp-fastopt-bundle.js.\nThis is because scalajs-bundler is combining your code with all your other js dependencies into one big bundle, hence the name change.\nNote: Behind the scenes, parcel.js does the same thing, it\u0026rsquo;s just not as obvious and doesn\u0026rsquo;t require you to do anything.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/goodies/",
	"title": "Built-in Goodies",
	"tags": [],
	"description": "",
	"content": "Tyrian comes with a number of handy functions built-in that you can make use of and explore:\nBuilt-in Cmd goodies These nuggets of functionality are used as commands.\nDom - A few methods such as focus and blur to manipulate the DOM. Inspired by the Elm Browser.Dom package. FileReader - Given the id of a file input field that has had a file selected, this Cmd will read either an image or text file to return an HTMLImageElement or String respectively. Http - Make HTTP requests that return their responses as a message. ImageLoader - Given a path, this cmd will load an image and return an HTMLImageElement for you to make use of. LocalStorage - Allows you to save and load to/from your browsers local storage. Logger - A simple logger that logs to the Browsers console with a few standard headers and the log message. Random - A Cmd to generate random values. In the examples below, we will be using this catch-all ADT, here it is for reference.\nimport org.scalajs.dom.html enum Msg: case Read(contents: String) case UseImage(img: html.Image) case RandomValue(value: String) case Error(message: String) case Empty case NoOp Dom Assuming two messages Error and Empty, we can attempt to focus a given ID.\nimport cats.effect.IO import tyrian.* import tyrian.cmds.* val cmd: Cmd[IO, Msg] = Dom.focus(\u0026#34;my-id\u0026#34;) { case Left(Dom.NotFound(id)) =\u0026gt; Msg.Error(s\u0026#34;ID $id not found\u0026#34;) case Right(_) =\u0026gt; Msg.Empty } Dom.blur works in the same way, though, performing the opposite effect.\nFileReader Will read any file data, with build in support for text and images.\nAssuming two messages Error and Read, we can attempt to read the contents of a text file.\nimport tyrian.cmds.* val cmd: Cmd[IO, Msg] = FileReader.readText(\u0026#34;my-file-input-field-id\u0026#34;) { case FileReader.Result.Error(msg) =\u0026gt; Msg.Error(msg) case FileReader.Result.File(name, path, contents) =\u0026gt; Msg.Read(contents) } Http Please see Networking for details.\nImageLoader Given a path, this cmd will load an image and create and return an HTMLImageElement for you to make use of.\nimport tyrian.cmds.* val cmd: Cmd[IO, Msg] = ImageLoader.load(\u0026#34;path/to/img.png\u0026#34;) { case ImageLoader.Result.ImageLoadError(msg, path) =\u0026gt; Msg.Error(msg) case ImageLoader.Result.Image(imageElement) =\u0026gt; Msg.UseImage(imageElement) } LocalStorage A series of commands that mirror the localstorage interface.\nimport tyrian.cmds.* val cmd: Cmd[IO, Msg] = Cmd.Batch[IO, Msg]( LocalStorage.setItem(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) { case LocalStorage.Result.Success =\u0026gt; Msg.NoOp case e =\u0026gt; Msg.Error(e.toString) }, LocalStorage.getItem(\u0026#34;key\u0026#34;) { case Right(LocalStorage.Result.Found(value)) =\u0026gt; Msg.Read(value) case Left(LocalStorage.Result.NotFound(e)) =\u0026gt; Msg.Error(e.toString) }, LocalStorage.removeItem(\u0026#34;key\u0026#34;) { case LocalStorage.Result.Success =\u0026gt; Msg.NoOp case e =\u0026gt; Msg.Error(e.toString) }, LocalStorage.clear { case LocalStorage.Result.Success =\u0026gt; Msg.NoOp case e =\u0026gt; Msg.Error(e.toString) }, LocalStorage.key(0) { case LocalStorage.Result.Key(keyAtIndex0) =\u0026gt; Msg.Read(keyAtIndex0) case LocalStorage.Result.NotFound(e) =\u0026gt; Msg.Error(e.toString) case e =\u0026gt; Msg.Error(e.toString) }, LocalStorage.length { case LocalStorage.Result.Length(value) =\u0026gt; Msg.Read(value.toString) } ) Logger Allows you to log to your browsers JavaScript console:\nimport tyrian.cmds.* val cmd: Cmd[IO, Msg] = Logger.info(\u0026#34;Log this!\u0026#34;) If you\u0026rsquo;re app is doing a lot of regular work, you can cut down the noise with the \u0026lsquo;once\u0026rsquo; versions:\nimport tyrian.cmds.* val cmd: Cmd[IO, Msg] = Logger.debugOnce(\u0026#34;Log this exact message only once!\u0026#34;) Random As you might expect, Random produces random values! Random works slightly differently from other commands, in that it doesn\u0026rsquo;t except a conversion function to turn the result into a message. You do that by mapping over it.\nAssuming a message RandomValue, here are a few examples:\nimport tyrian.cmds.* val toMessage = (v: String) =\u0026gt; Msg.RandomValue(v) val cmd: Cmd[IO, Msg] = Cmd.Batch( Random.int[IO].map(i =\u0026gt; toMessage(i.value.toString)), Random.shuffle[IO, Int](List(1, 2, 3)).map(l =\u0026gt; toMessage(l.value.toString)), Random.Seeded(12l).alphaNumeric[IO](5).map(a =\u0026gt; toMessage(a.value.mkString)) ) Built-in Cmd + Sub goodies These tools make use of a combination of commands and subscriptions to achieve a result. Note that unlike in the next section, these entries share nothing apart from, say, a key value, i.e. there is no common state to manage or store in a model.\nHotReload - Store the state of your app, so you can carry on where you left off after a recompile! Navigation - Manage hash/anchor based browser navigation, allowing you to navigate around your app. Built-in Pub/Sub goodies These entries form a pub/sub relationship where you are required to store an object that holds state in your app\u0026rsquo;s model, and which allows you to then subscribe to events and publish messages via given Subs and Cmds respectively.\nWebSocket - Allows you to send and receive data to/from a socket server (see Networking). TyrianIndigoBridge - Allows your Tyrian app to communicates with embedded Indigo games. "
},
{
	"uri": "https://tyrian.indigoengine.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/cmd/",
	"title": "Commands &amp; Effects",
	"tags": [],
	"description": "",
	"content": "Commands Using Tyrian, you can get a long way with nothing more than a model, a view, and some messages being pumped around their endless one-way circuit.\nHowever, sooner or later you are going to want to do something that appears to break the loop, for instance:\nMake an HTTP call Log a message to the console Invoke a download Draw to a canvas These kinds of actions are called \u0026lsquo;side-effects\u0026rsquo;, and are an extremely popular talking point with functional programmers, because they represent the very moment that all their beautiful functional purity goes right out the window.\nLuckily, Tyrian has a pretty elegant solution for this.\nMonadic effect handling You can skip this bit of context if you like. This section has a bit of jargon in it for those who care about such things, but it\u0026rsquo;s really not important if you just want to know how to use commands.\nThe usual approach to handling effects (short for side effects) is to employ some sort of effect monad that captures your side effect as a lazy value.\nThis is exactly what a command (Cmd) does. While commands themselves are only Monoidal Functors*, they work using Cats Effect 3 under the covers.\n(* Meaning you can map over them, they can be combined together, and have an empty state Cmd.None.)\nSo far, this is sounding like effect handling as usual. But no. Primarily because you rarely actually see the underlying effect type.\nMaking things happen Commands take the form Cmd[IO, Msg] (IO is used for illustrative purposes) which is to say that they represent some sort of side effect that can produce a message to be cleanly fed back into your single page application\u0026rsquo;s updateModel function.\nCommands can be produced as part of a result of calling the init or updateModel functions, which both return a (Model, Cmd[IO, Msg]).\nHere is an example in which, on receiving a message Msg.LogThis, we are not going to change the model, but we want to write to the browser\u0026rsquo;s JavaScript console:\nimport tyrian.* import tyrian.cmds.* import cats.effect.IO type Model = Int enum Msg: case LogThis(message: String) def update(model: Model): Msg =\u0026gt; (Model, Cmd[IO, Msg]) = case Msg.LogThis(msg) =\u0026gt; (model, Logger.consoleLog(msg)) To achieve this, we use the Logger command that comes with Tyrian. The Logger command is in fact just a Cmd.SideEffect that captures a value or behavior as a zero argument function, known as a thunk, in this case a simplified implementation could just be:\ndef consoleLog(msg: String): Cmd[IO, Nothing] = Cmd.SideEffect { println(msg) } But commands can also return values in the form of messages. The Random command looks like this:\nRandom.double[IO] \u0026hellip;and produces an instance of RandomValue, but this leads to a problem since RandomValue is almost certainly not your app\u0026rsquo;s Msg type, and so we must map over the result:\nenum MyMsg: case MyRandom(d: Double) extends MyMsg Random.double[IO].map(next =\u0026gt; MyMsg.MyRandom(next.value)) These are simple examples, but there are much more complicated uses for commands. One great use of commands is for making HTTP requests where the response is decoded into a Msg.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/networking/",
	"title": "Networking",
	"tags": [],
	"description": "",
	"content": "Out of the box, Tyrian supports two flavors of networking, HTTP and Web Sockets, and we have examples you can run of both. Please see the instructions in the README file.\nIt should be said that both implementations are quite primitive at the time of writing. Contributions in the form of issues and improvements are very welcome in this area. No doubt they will be improved as the need arises.\nHttp tyrian.http.Http is a built-in Cmd that defines the following method:\nobject Http: def send[F[_]: Async, A, Msg]( request: Request[A], resultToMessage: Decoder[Msg] ): Cmd[F, Msg] Additionally, Tyrian also integrates with http4s-dom.\nFetch random GIF via HTTP Assuming the following imports:\nimport cats.effect.IO import cats.syntax.either.* import io.circe.HCursor import io.circe.parser.* import tyrian.* import tyrian.cmds.* import tyrian.http.* import tyrian.Html.* Let\u0026rsquo;s walk through this example starting with the Model1 and Msg1 types.\nfinal case class Model1(topic: String, gifUrl: String) enum Msg1: case MorePlease extends Msg1 case NewGif(result: String) extends Msg1 case GifError(error: String) extends Msg1 Followed by a Decoder[Msg1] needed to parse the HTTP responses.\nobject Msg1: def jsonDecode(hcursor: HCursor) = hcursor .downField(\u0026#34;data\u0026#34;) .downField(\u0026#34;images\u0026#34;) .downField(\u0026#34;downsized_medium\u0026#34;) .get[String](\u0026#34;url\u0026#34;) .toOption .toRight(\u0026#34;wrong json format\u0026#34;) private val onResponse: Response =\u0026gt; Msg1 = { response =\u0026gt; parse(response.body) .leftMap(_.message) .flatMap(j =\u0026gt; jsonDecode(j.hcursor)) .fold(Msg1.GifError(_), Msg1.NewGif(_)) } private val onError: HttpError =\u0026gt; Msg1 = e =\u0026gt; Msg1.GifError(e.toString) def fromHttpResponse: Decoder[Msg1] = Decoder[Msg1](onResponse, onError) Next we have an HttpHelper that invokes the Http.send method using Giphy\u0026rsquo;s API.\nobject HttpHelper: def url(topic: String) = s\u0026#34;https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC\u0026amp;tag=$topic\u0026#34; def getRandomGif(topic: String): Cmd[IO, Msg1] = Http.send(Request.get(url(topic)), Msg1.fromHttpResponse) Ultimately, we can use it in our init and update methods, or anywhere where a Cmd[IO, Msg1] is expected. For example:\nobject HttpMain: def init(flags: Map[String, String]): (Model1, Cmd[IO, Msg1]) = (Model1(\u0026#34;cats\u0026#34;, \u0026#34;waiting.gif\u0026#34;), HttpHelper.getRandomGif(\u0026#34;cats\u0026#34;)) def update(model: Model1): Msg1 =\u0026gt; (Model1, Cmd[IO, Msg1]) = case Msg1.MorePlease =\u0026gt; (model, HttpHelper.getRandomGif(model.topic)) case Msg1.NewGif(newUrl) =\u0026gt; (model.copy(gifUrl = newUrl), Cmd.None) case Msg1.GifError(_) =\u0026gt; (model, Cmd.None) You can find the full code on the examples directory linked at the top.\nHttp4s-dom integration To use http4s-dom instead, we only need to replace the HttpHelper with the following implementation.\nimport io.circe.{ Decoder as JsonDecoder, DecodingFailure } import org.http4s.circe.CirceEntityCodec.* import org.http4s.dom.FetchClientBuilder object Http4sDomHelper: private val client = FetchClientBuilder[IO].create given JsonDecoder[Msg1] = JsonDecoder.instance { c =\u0026gt; Msg1.jsonDecode(c).map(Msg1.NewGif(_)).leftMap(e =\u0026gt; DecodingFailure(e, c.history)) } def getRandomGif(topic: String): Cmd[IO, Msg1] = val fetchGif: IO[Msg1] = client .expect[Msg1](HttpHelper.url(topic)) .handleError(e =\u0026gt; Msg1.GifError(e.getMessage)) Cmd.Run(fetchGif)(identity) Web Sockets Another built-in command is tyrian.websocket.WebSocket, which has a more complex API.\nfinal class WebSocket[F[_]: Async](liveSocket: LiveSocket[F]): def disconnect[Msg]: Cmd[F, Msg] def publish[Msg](message: String): Cmd[F, Msg] def subscribe[Msg](f: WebSocketEvent =\u0026gt; Msg): Sub[F, Msg] /** The running instance of the WebSocket */ final class LiveSocket[F[_]: Async](val socket: dom.WebSocket, val subs: Sub[F, WebSocketEvent]) object WebSocket: def connect[F[_]: Async, Msg]( address: String, onOpenMessage: String, keepAliveSettings: KeepAliveSettings )( resultToMessage: WebSocketConnect[F] =\u0026gt; Msg ): Cmd[F, Msg] Having a WebSocket instance allows us to publish messages (Cmd[F, Msg]), subscribe to events (Sub[F, Msg]), and explicitly disconnect (another Cmd[F, Msg]) from the server. To initiate a connection, we can use any of the available connect methods defined on its companion object.\nWS echo server The following example demonstrates the usage of WebSocket, starting with the following imports:\nimport cats.effect.IO import tyrian.Html.* import tyrian.* import tyrian.cmds.Logger import tyrian.websocket.* Next we have the Msg and Model types.\nenum Msg: case FromSocket(message: String) case ToSocket(message: String) case WebSocketStatus(status: EchoSocket.Status) final case class Model(echoSocket: EchoSocket, log: List[String]) object Model: val init: Model = Model(EchoSocket.init, Nil) Followed by a custom EchoSocket class that handles the connection by reacting to EchoSocket.Status messages. The handling of the Connecting message is of particular interest, as it initiates the socket connection via WebSocket.connect, including keep-alive settings.\nfinal case class EchoSocket(socketUrl: String, socket: Option[WebSocket[IO]]): def connectDisconnectButton = if socket.nonEmpty then button(onClick(EchoSocket.Status.Disconnecting.asMsg))(\u0026#34;Disconnect\u0026#34;) else button(onClick(EchoSocket.Status.Connecting.asMsg))(\u0026#34;Connect\u0026#34;) def update(status: EchoSocket.Status): (EchoSocket, Cmd[IO, Msg]) = status match case EchoSocket.Status.ConnectionError(err) =\u0026gt; (this, Logger.error(s\u0026#34;Failed to open WebSocket connection: $err\u0026#34;)) case EchoSocket.Status.Connected(ws) =\u0026gt; (this.copy(socket = Some(ws)), Cmd.None) case EchoSocket.Status.Connecting =\u0026gt; val connect = WebSocket.connect[IO, Msg]( address = socketUrl, onOpenMessage = \u0026#34;Connect me!\u0026#34;, keepAliveSettings = KeepAliveSettings.default ) { case WebSocketConnect.Error(err) =\u0026gt; EchoSocket.Status.ConnectionError(err).asMsg case WebSocketConnect.Socket(ws) =\u0026gt; EchoSocket.Status.Connected(ws).asMsg } (this, connect) case EchoSocket.Status.Disconnecting =\u0026gt; val log = Logger.info[IO](\u0026#34;Graceful shutdown of EchoSocket connection\u0026#34;) val cmds = socket.map(ws =\u0026gt; Cmd.Batch(log, ws.disconnect)).getOrElse(log) (this.copy(socket = None), cmds) case EchoSocket.Status.Disconnected =\u0026gt; (this, Logger.info(\u0026#34;WebSocket not connected yet\u0026#34;)) def publish(message: String): Cmd[IO, Msg] = socket.map(_.publish(message)).getOrElse(Cmd.None) def subscribe(toMessage: WebSocketEvent =\u0026gt; Msg): Sub[IO, Msg] = socket.fold(Sub.emit[IO, Msg](EchoSocket.Status.Disconnected.asMsg)) { _.subscribe(toMessage) } object EchoSocket: val init: EchoSocket = EchoSocket(\u0026#34;wss://ws.ifelse.io/\u0026#34;, None) enum Status: case Connecting case Connected(ws: WebSocket[IO]) case ConnectionError(msg: String) case Disconnecting case Disconnected def asMsg: Msg = Msg.WebSocketStatus(this) At last, we can see how to handle socket messages and status changes in our update method.\ndef update(model: Model): Msg =\u0026gt; (Model, Cmd[IO, Msg]) = case Msg.WebSocketStatus(status) =\u0026gt; val (nextWS, cmds) = model.echoSocket.update(status) (model.copy(echoSocket = nextWS), cmds) case Msg.FromSocket(message) =\u0026gt; val logWS = Logger.info[IO](\u0026#34;Got: \u0026#34; + message) (model.copy(log = message :: model.log), logWS) case Msg.ToSocket(message) =\u0026gt; val cmds: Cmd[IO, Msg] = Cmd.Batch( Logger.info(\u0026#34;Sent: \u0026#34; + message), model.echoSocket.publish(message) ) (model, cmds) Moreover, the subscriptions method handles Web Socket events.\ndef subscriptions(model: Model): Sub[IO, Msg] = model.echoSocket.subscribe { case WebSocketEvent.Error(errorMesage) =\u0026gt; Msg.FromSocket(errorMesage) case WebSocketEvent.Receive(message) =\u0026gt; Msg.FromSocket(message) case WebSocketEvent.Open =\u0026gt; Msg.FromSocket(\u0026#34;\u0026lt;no message - socket opened\u0026gt;\u0026#34;) case WebSocketEvent.Close(code, reason) =\u0026gt; Msg.FromSocket(s\u0026#34;\u0026lt;socket closed\u0026gt; - code: $code, reason: $reason\u0026#34;) case WebSocketEvent.Heartbeat =\u0026gt; Msg.ToSocket(\u0026#34;\u0026lt;ðŸ’“ heartbeat ðŸ’“\u0026gt;\u0026#34;) } The full code can be found on the examples linked at the top.\nFurthermore, you may also find the trading project useful: a full-stack application with a Web Socket client sharing the back-end domain model.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/html/",
	"title": "Rendering HTML",
	"tags": [],
	"description": "",
	"content": "HTML syntax In Tyrian, you describe your view in Scala and the VirtualDom implementation that powers Tyrian (Scala.js Snabbdom) renders that description into HTML.\nHere is a simple made up example of the syntax to give you a flavor:\nimport tyrian.* import tyrian.Html.* import tyrian.CSS enum Msg: case Greet val myStyles = style(CSS.`font-family`(\u0026#34;Arial, Helvetica, sans-serif\u0026#34;)) val topLine = p(b(text(\u0026#34;This is some HTML in bold.\u0026#34;))) div(id := \u0026#34;my-container\u0026#34;)( div(myStyles)( topLine, p(\u0026#34;Hello, world!\u0026#34;), button(onClick(Msg.Greet))(\u0026#34;Say hello!\u0026#34;) ) ) Working with Tags, Attributes and Properties A vast list of the common HTML tags, attributes, and CSS property types have been generated for you, and effort has gone in to making the experience reasonably pleasant.\nThe arrangement of tags follows similar approaches by other compiled languages trying to represent HTML:\ntag-name(List(attributes, ...))(List(children, ...))\nFor example, here we have a span with an attribute and a child element:\nspan(`class` := \u0026#34;green-box\u0026#34;)( p(\u0026#34;This is some text.\u0026#34;) ) You can omit the attributes and the syntax is valid:\nspan( p(\u0026#34;This is some text.\u0026#34;) ) Note that plain text can be declare as text or just omitted, in other words these are equivalent:\np(\u0026#34;some text\u0026#34;) p(text(\u0026#34;some text\u0026#34;)) To distinguish them from similarly named tags (e.g. the title attribute and the title tag\u0026hellip;), attributes are declared as attribute-name := attribute-value, e.g.:\nid := \u0026#34;my-container\u0026#34; Some HTML attributes / properties use Scala reserved words, and so have a variety of encodings to suit all tastes. For example class is a Scala reserved word and you cannot use it directly, but you can use any of these instead:\n`class` cls className _class Styles are also baked in, albeit it in a slightly crude way, but you will get some IDE support. You can do things like the following:\np(style(CSS.`font-weight`(\u0026#34;bold\u0026#34;)))(\u0026#34;Hello\u0026#34;) SVG You can also pull in SVG tags and attributes using:\nimport tyrian.SVG.* CSS Many standard CSS terms can be imported using:\nimport tyrian.CSS.* Rolling your own If you find we\u0026rsquo;ve missed a tag or attribute or something, please raise an issue. In the meantime, you can always make your own. Here are just a few made up examples, each of these has numerous constructors for you to explore:\n// A \u0026#39;canvas\u0026#39; tag tag(\u0026#34;canvas\u0026#34;)(id := \u0026#34;an-id\u0026#34;)(Nil) // or Tag(\u0026#34;canvas\u0026#34;, List(id := \u0026#34;an-id\u0026#34;), Nil) // An attribute attribute(\u0026#34;my-attribute\u0026#34;, \u0026#34;its-value\u0026#34;) // A property property(\u0026#34;my-property\u0026#34;, \u0026#34;its-value\u0026#34;) // Styles style(\u0026#34;width\u0026#34;, \u0026#34;100px\u0026#34;) styles(\u0026#34;width\u0026#34; -\u0026gt; \u0026#34;100px\u0026#34;, \u0026#34;height\u0026#34; -\u0026gt; \u0026#34;50px\u0026#34;) // An event-type attribute onEvent(\u0026#34;click\u0026#34;, (evt: Tyrian.Event) =\u0026gt; Msg.Greet) Note that everything is stringly typed, and that\u0026rsquo;s because in HTML everything is stringly typed too! In the generated tags, we\u0026rsquo;ve added support for things like attributes accepting Ints and Booleans and so on where they have known acceptable input types.\nKnown Gotcha: Attributes vs. Properties One occasion where you may need to make your own tags or attributes etc., is when Tyrian has an incorrectly declared definition of something or other.\nA previous case of this was where the input field value property was incorrectly declared as an attribute, and so the value wasn\u0026rsquo;t changed as expected based on model updates.\nEffort has gone in to getting these things right, but if you come across any issues, please report them, and the workaround is to re-declare it yourself as above while a fix is produced.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/ssr/",
	"title": "Server-side Rendering (SSR)",
	"tags": [],
	"description": "",
	"content": "What is server-side rendering? These days, a normal straight-forward relationship between a frontend client and some sort of backend service, is that the client makes an HTTP request to the service, and receives some data back that it uses to render a page/view for the user. But it wasn\u0026rsquo;t always so!\nBack in the days when Perl dominated the world of server side technology and ASP was new and exciting, it was more normal for the browser to hit a url, and for the page rendering to happen entirely on the server: The HTML delivered whole and fully formed to the browser. This allow the pages to be built up from data pulled from other services and databases.\nThis arrangement has come back into fashion, and now has the fancy name \u0026ldquo;server-side rendering\u0026rdquo; or SSR. The benefit of SSR is that HTML is incredibly cache-able. If you can manufacture a page or a fragment of a page once, then you may be able to cache it for super fast page loading performance.\nSimple SSR with Tyrian Below is a simple example of SRR with Tyrian:\nimport tyrian.* import tyrian.Html.* val styles = style(CSS.`font-family`(\u0026#34;Arial, Helvetica, sans-serif\u0026#34;)) val topLine = p(b(text(\u0026#34;HTML fragment rendered by Tyrian on the server.\u0026#34;))) Tyrian.render( div(styles)( topLine, p(\u0026#34;Hello, world!\u0026#34;) ) ) As you can see, this is completely ordinary Scala, which means you can do anything that Scala lets you do in order to generate this HTML block, without having to learn a templating language like Mustache.\nThere are a number of variations of the Tyrian.render function, full details can be found in the Tyrian API docs.\nThere is an example of SRR in the server-examples.\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/subs/",
	"title": "Subscriptions",
	"tags": [],
	"description": "",
	"content": "Subscriptions: A notification of change Subscriptions (Subs) are used to observe something that changes over time, and to emit discrete messages when something happens.\nFor example, we could chose to observe the mouse position, and emit a message every time the mouse moves, like this:\nimport org.scalajs.dom.document import org.scalajs.dom.MouseEvent import cats.effect.IO import tyrian.* type Model = Int enum Msg: case MouseMove(x: Double, y: Double) val mousePosition: Sub[IO, Msg] = Sub.fromEvent(\u0026#34;mousemove\u0026#34;, document) { case e: MouseEvent =\u0026gt; Option(Msg.MouseMove(e.pageX, e.pageY)) } def subscriptions(model: Model): Sub[IO, Msg] = mousePosition A change in mouse position will now result in a MouseMove message that will be piped back to your updateModel function.\nSubscriptions can be used on their own, or in conjunction with commands to form a pub/sub relationship with a resource, as is the case with web sockets and the tyrian-indigo bridge.\nWorking with Subscriptions Subscriptions are Functors which means that you can map over them to change the resultant message. They are also Monoids which means that they have an empty representation Sub.None and that you can combine them together, using combine or the shorthand operator: sub1 |+| sub2.\nA common thing to need to do is batch multiple subs together into a single subscription, like this:\nimport scala.concurrent.duration._ import org.scalajs.dom.document import org.scalajs.dom.MouseEvent import tyrian.* enum Msg: case MouseMove(x: Double, y: Double) case CurrentSeconds(seconds: Double) val mousePosition: Sub[IO, Msg] = Sub.fromEvent(\u0026#34;mousemove\u0026#34;, document) { case e: MouseEvent =\u0026gt; Option(Msg.MouseMove(e.pageX, e.pageY)) } val tick = Sub.every[IO](1.second, \u0026#34;tick\u0026#34;) .map(date =\u0026gt; Msg.CurrentSeconds(date.getSeconds())) def subscriptions(model: Model): Sub[IO, Msg] = Sub.Batch[IO, Msg]( mousePosition, tick ) "
},
{
	"uri": "https://tyrian.indigoengine.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tyrian.indigoengine.io/",
	"title": "Tyrian",
	"tags": [],
	"description": "",
	"content": "Tyrian Tyrian is an Elm-inspired, purely functional UI library for Scala 3.\nIts purpose is to make building interactive websites in Scala 3 fun! Tyrian allows you to describe web pages and complex interactions in a way that is elegant, easy to read and easy to reason about.\nTyrian is not designed to work alone, the intention is that you will use it alongside a web bundler to look after things like your media assets and stylesheets. (All our examples use Parcel.)\nTyrian ðŸ’œ\u0026rsquo;s Indigo Tyrian is by the maintainers of Indigo, a Scala 3 game engine. As such, Indigo web games are first class citizens in Tyrian, allowing easy embedding and seamless communication between their respective event/messaging systems.\nWhen should I consider using Tyrian? Tyrian is designed for building SPAs (Single Page Applications): Web pages with lots of interactive elements.\nOne use case we\u0026rsquo;re particularly excited about is augmenting Indigo games with rich HTML UI elements.\nYou can also use Tyrian to do Server-side Rendering (SSR) in conjunction with your favorite Scala HTTP framework in place of, say, a templating library.\nWhat should I avoid using Tyrian for? Tyrian is not a great candidate for static websites - like this one! - where the content is there to be read, not interacted / played / engaged with.\nWhy shouldn\u0026rsquo;t I just use some Scala.js-React-based-thingy instead? You can! Quite frankly, you probably should!\nIn fact there are a good number of Scala.js alternatives to Tyrian, such as Outwatch, scalajs-react, Slinky, and Laminar to name a few.\nReact in particular is an industry standard framework these days, and so there are lots and lots of resources out there to help you use it. In that regard at least, React (via Slinky or scalajs-react) is probably a good choice for beginners.\nFunctional programmers may be more into something like Laminar, which is based on Functional Reactive Programming (FRP). Laminar looks to be well made and well maintained, and there are some great talks out there about it.\nTyrian works fundamentally differently to those other frameworks. In the authors very opinionated opinion: The Elm Architecture upon which it is based, is the most productive, fun, and sane frontend architectural approach there is.\nThis library exists because we don\u0026rsquo;t want to work any other way. We encourage you to try a few different approaches and decide what works best for you. ðŸ˜Š\n"
},
{
	"uri": "https://tyrian.indigoengine.io/concepts/tyrian-indigo-bridge/",
	"title": "Tyrian-Indigo Bridge",
	"tags": [],
	"description": "",
	"content": "What if you wanted to make a web game (or an Electron desktop game - why not!), where the main game window was rendered in WebGL, but the UI elements were all in lovely, responsive, scalable HTML5?\nThe main problem is how you get the two parts to talk to one another. If everything is written in JavaScript, that\u0026rsquo;s not such a problem because it\u0026rsquo;s all the same language, the two systems are likely to be idiomatically similar, and with JavaScript \u0026hellip;well, you can do pretty much anything you like.\nIf you want to use Scala.js, things get more complicated.\nTyrian ðŸ’œ\u0026rsquo;s Indigo One of the reasons Tyrian was resurrected from the ashes of it\u0026rsquo;s predecessor Scalm was that we love working with this architecture pattern, the TEA pattern. Indigo our game engine, uses a variation on the same design.\nBoth use the same language\u0026hellip; both use the same idioms\u0026hellip; why not join them together?\nRunnable Example Rather than go into all the details of how it works, there is an example you can look at the demonstrates how the two can seamlessly communicate using lovely native Scala types.\nNote that the example is quite simple and just uses String as it\u0026rsquo;s message format, but you can use whatever suits your needs.\nOverview making Tyrian work with Indigo Assuming you have a skeletal Tyrian project, and right next to it in the same code base a basic Indigo game (Tip: namespacing the game to its own package is a good idea\u0026hellip; you\u0026rsquo;re about to have two models!):\nThe Bridge The way the bridge works is that the Tyrian side holds an instance of the bridge in it\u0026rsquo;s model, and Indigo runs a subsystem for that bridge.\nIndigo SubSystems are like mini-games that have most of the same functions as the main game, but can only talk via messages - sort of like background workers.\nThe Bridge is a JavaScript EventTarget, and both Indigo and Tyrian latch on. In both instances their job is to send and receive messages via the brigde event target and convert them to their native event/messaging system.\nEstablishing a connection Indigo needs a container to latch onto, so Tyrian provides that in it\u0026rsquo;s rendered view. During init, you start up the bridge and put it in your model, then use a Cmd.Emit to tell the updateModel function to start the game. An Indigo game can then be trivially launched using a Cmd.SideEffect that literally calls your game\u0026rsquo;s launch function in plain ole Scala, injecting the bridge provided SubSystem into the game. Important: The key tools you need are now all on your bridge instance. Your bridge instance will give you the Indigo SubSystem for you, it also has the publish Cmd and the subscribe Sub that you need.\nPublishing and Subscribing Note that Indigo uses the term \u0026rsquo;event\u0026rsquo; and Tyrian uses \u0026lsquo;message\u0026rsquo;. The behavior is slightly different between the two, but for our purposes here, they should be considered the same thing.\nIn Indigo Indigo now has a new GlobalEvent type, TyrianEvent which can be a TyrianEvent.Send(value: A) or TyrianEvent.Receive(value: A) where the A type is declared with the SubSystem.\nTo listen for messages from Tyrian, you simply match on the TyrianEvent.Receive(value: A) in one of you update functions.\nTo send a message to Tyrian, you emit a message as normal, e.g.:\nimport indigo.* import tyrian.* import cats.effect.IO val bridge: TyrianIndigoBridge[IO, String] = TyrianIndigoBridge() val subsystem: TyrianSubSystem[IO, String] = TyrianSubSystem(bridge) val model: Int = 10 // Sending a string here, but could be anything. Outcome(model).addGlobalEvents(subsystem.TyrianEvent.Send(\u0026#34;My message\u0026#34;)) Please note that the example above is rather contrived to try and show you the code, it\u0026rsquo;s better to look at a real example.\nIn Tyrian Tyrian by now has a reference to the bridge in your model.\nTo listen for messages from Indigo, all you have to do is plumb in the model.bridge.subscribe Sub[IO, Msg] into your app\u0026rsquo;s subscriptions feed, and provide an extractor to tell it how to convert the events into messages.\nTo send message to Indigo, you call bridge.send(myMsg) which provides a Cmd[IO, Msg] for you to plug into your updateModel result.\nThat\u0026rsquo;s it In a nutshell, that is the whole set up. Happy web game building!\n"
}]