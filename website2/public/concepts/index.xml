<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Core Concepts on Tyrian</title>
    <link>https://tyrian.indigoengine.io/concepts/</link>
    <description>Recent content in Core Concepts on Tyrian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language><atom:link href="https://tyrian.indigoengine.io/concepts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A Guided Example</title>
      <link>https://tyrian.indigoengine.io/concepts/guided-tour/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/guided-tour/</guid>
      <description>The normal use case for Tyrian is to build a Single Page App/Application (SPA). You can also use Tyrian for Server-side Rendering (SSR), but this page will focus on SPAs.
A guided example Let&amp;rsquo;s walk through an example to see what goes into a Tyrian App.
The &amp;lsquo;counter&amp;rsquo; is a very common example you&amp;rsquo;ll come across for many frameworks, it&amp;rsquo;s a handy Rosetta stone for when you need to orientate yourself in a new framework quickly.</description>
    </item>
    
    <item>
      <title>Building &amp; Bundling</title>
      <link>https://tyrian.indigoengine.io/concepts/bundling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/bundling/</guid>
      <description>The JavaScript community don&amp;rsquo;t like to use the word &amp;lsquo;compiler&amp;rsquo;, but tools that gather, parse, and link source files into deployable &amp;lsquo;bundles&amp;rsquo; are an essential part of modern web app development.
These tools are called &amp;lsquo;bundlers&amp;rsquo;, the most well known of which is probably Webpack. It is beyond the scope of these docs to explain how bundlers work, but they are well documented tools.
Tyrian needs bundlers too. We could probably manage without them for our raw app, but sooner or later we&amp;rsquo;re bound to need images, and style sheets, and font files, and other JS libraries etc.</description>
    </item>
    
    <item>
      <title>Built-in Goodies</title>
      <link>https://tyrian.indigoengine.io/concepts/goodies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/goodies/</guid>
      <description>Tyrian comes with a number of handy functions built-in that you can make use of and explore:
Built-in Cmd goodies These nuggets of functionality are used as commands.
Dom - A few methods such as focus and blur to manipulate the DOM. Inspired by the Elm Browser.Dom package. FileReader - Given the id of a file input field that has had a file selected, this Cmd will read either an image or text file to return an HTMLImageElement or String respectively.</description>
    </item>
    
    <item>
      <title>Commands &amp; Effects</title>
      <link>https://tyrian.indigoengine.io/concepts/cmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/cmd/</guid>
      <description>Commands Using Tyrian, you can get a long way with nothing more than a model, a view, and some messages being pumped around their endless one-way circuit.
However, sooner or later you are going to want to do something that appears to break the loop, for instance:
Make an HTTP call Log a message to the console Invoke a download Draw to a canvas These kinds of actions are called &amp;lsquo;side-effects&amp;rsquo;, and are an extremely popular talking point with functional programmers, because they represent the very moment that all their beautiful functional purity goes right out the window.</description>
    </item>
    
    <item>
      <title>Networking</title>
      <link>https://tyrian.indigoengine.io/concepts/networking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/networking/</guid>
      <description>Out of the box, Tyrian supports two flavors of networking, HTTP and Web Sockets, and we have examples you can run of both. Please see the instructions in the README file.
It should be said that both implementations are quite primitive at the time of writing. Contributions in the form of issues and improvements are very welcome in this area. No doubt they will be improved as the need arises.</description>
    </item>
    
    <item>
      <title>Rendering HTML</title>
      <link>https://tyrian.indigoengine.io/concepts/html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/html/</guid>
      <description>HTML syntax In Tyrian, you describe your view in Scala and the VirtualDom implementation that powers Tyrian (Scala.js Snabbdom) renders that description into HTML.
Here is a simple made up example of the syntax to give you a flavor:
import tyrian.* import tyrian.Html.* import tyrian.CSS enum Msg: case Greet val myStyles = style(CSS.`font-family`(&amp;#34;Arial, Helvetica, sans-serif&amp;#34;)) val topLine = p(b(text(&amp;#34;This is some HTML in bold.&amp;#34;))) div(id := &amp;#34;my-container&amp;#34;)( div(myStyles)( topLine, p(&amp;#34;Hello, world!</description>
    </item>
    
    <item>
      <title>Server-side Rendering (SSR)</title>
      <link>https://tyrian.indigoengine.io/concepts/ssr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/ssr/</guid>
      <description>What is server-side rendering? These days, a normal straight-forward relationship between a frontend client and some sort of backend service, is that the client makes an HTTP request to the service, and receives some data back that it uses to render a page/view for the user. But it wasn&amp;rsquo;t always so!
Back in the days when Perl dominated the world of server side technology and ASP was new and exciting, it was more normal for the browser to hit a url, and for the page rendering to happen entirely on the server: The HTML delivered whole and fully formed to the browser.</description>
    </item>
    
    <item>
      <title>Subscriptions</title>
      <link>https://tyrian.indigoengine.io/concepts/subs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/subs/</guid>
      <description>Subscriptions: A notification of change Subscriptions (Subs) are used to observe something that changes over time, and to emit discrete messages when something happens.
For example, we could chose to observe the mouse position, and emit a message every time the mouse moves, like this:
import org.scalajs.dom.document import org.scalajs.dom.MouseEvent import cats.effect.IO import tyrian.* type Model = Int enum Msg: case MouseMove(x: Double, y: Double) val mousePosition: Sub[IO, Msg] = Sub.fromEvent(&amp;#34;mousemove&amp;#34;, document) { case e: MouseEvent =&amp;gt; Option(Msg.</description>
    </item>
    
    <item>
      <title>Tyrian-Indigo Bridge</title>
      <link>https://tyrian.indigoengine.io/concepts/tyrian-indigo-bridge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tyrian.indigoengine.io/concepts/tyrian-indigo-bridge/</guid>
      <description>What if you wanted to make a web game (or an Electron desktop game - why not!), where the main game window was rendered in WebGL, but the UI elements were all in lovely, responsive, scalable HTML5?
The main problem is how you get the two parts to talk to one another. If everything is written in JavaScript, that&amp;rsquo;s not such a problem because it&amp;rsquo;s all the same language, the two systems are likely to be idiomatically similar, and with JavaScript &amp;hellip;well, you can do pretty much anything you like.</description>
    </item>
    
  </channel>
</rss>
