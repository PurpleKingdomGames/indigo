package indigoextras.ui

import indigo.shared.time.GameTime

import scala.annotation.tailrec

/**
  * The interface for one step in an interleaved computation.
  *
  * @tparam ReferenceData Type of the static data made available to every step in the computation
  * @tparam ResultModel Type of the interleaved computation's (partial/complete) result
  */
trait MonitoredStep[ReferenceData, ResultModel] {

  /**
    * A representation of the relative size of this step compared to others, used to calculate
    * whether there is enough time to complete a step before the current frame ends. For example,
    * if one step's size is 1 and another step's size is 3, it is assumed that the latter step
    * will take roughly 3 times longer than the former step.
    */
  val size: Int

  /**
    * Perform this computation step.
    *
    * @param reference The static reference data available to all steps
    * @param current The running result produced by the computation steps prior to this one
    * @return The result state generated by this step
    */
  def perform(reference: ReferenceData, current: ResultModel): ResultModel
}

/**
  * Represents a computation whose steps are to be performed within frames, returning control
  * back to Indigo at the end of each frame to allow graphics and other elements to be updated.
  *
  * @param currentResult The result data object before the (remaining) steps are performed
  * @param referenceData Static data available for reference by all computation steps
  * @param steps The remaining computation steps
  * @param averageTimePerUnit The average time taken per computation step unit size
  * @param sizeCompleted The number of computation step units completed so far
  * @tparam ReferenceData Type of the static data made available to every step in the computation
  * @tparam ResultModel Type of the interleaved computation's (partial/complete) result
  */
final case class InterleavedComputation[ReferenceData, ResultModel](
    currentResult: ResultModel,
    referenceData: ReferenceData,
    steps: List[MonitoredStep[ReferenceData, ResultModel]],
    averageTimePerUnit: Double,
    sizeCompleted: Int
) {

  /**
    * Returns whether the whole computation (all steps) have been completed
    */
  lazy val isCompleted: Boolean = steps.isEmpty

  /**
    * Returns the size in computation step units that remains to be performed
    */
  lazy val sizeRemaining: Int = steps.map(_.size).sum

  /**
    * Returns the proportion of the computation completed from 0.0 (none) to 1.0 (all)
    */
  lazy val portionCompleted: Double = sizeCompleted.toDouble / (sizeCompleted + sizeRemaining)

  /**
    * Perform more of the computation, as many steps as are estimated will fit in the current
    * frame, but at least one in the case that by itself it is longer than the frame.
    *
    * @param gameTime The current game time, providing the frame duration
    * @return The new interleaved computation state after performing more steps
    */
  def performMore(gameTime: GameTime): InterleavedComputation[ReferenceData, ResultModel] =
    performMoreFrom(gameTime.frameDuration.value, 0L)

  /**
    * Recursive helper function to perform at least one step, and then more if there is still time.
    * @param frameDuration The duration of the frame
    * @param taken How long has been taken so far
    * @return The new interleaved computation state after performing more steps
    */
  @tailrec
  private def performMoreFrom(frameDuration: Long, taken: Long): InterleavedComputation[ReferenceData, ResultModel] =
    steps match {
      case Nil => this
      case first :: _ =>
        val start   = System.currentTimeMillis
        val updated = performStep
        if ((taken + (first.size * averageTimePerUnit).toLong) > frameDuration) updated
        else updated.performMoreFrom(frameDuration, taken + System.currentTimeMillis - start)
    }

  /**
    * Perform the next step of the computation, if any, and update the estimated average time
    * required per computation step unit size and amount completed.
    *
    * @return The new interleaved computation state after performing the next step.
    */
  def performStep: InterleavedComputation[ReferenceData, ResultModel] =
    steps match {
      case Nil => this
      case first :: rest =>
        val start        = System.currentTimeMillis
        val result       = first.perform(referenceData, currentResult)
        val duration     = System.currentTimeMillis - start
        val nowCompleted = sizeCompleted + first.size
        InterleavedComputation(
          result,
          referenceData,
          rest,
          (averageTimePerUnit * sizeCompleted + duration) / nowCompleted,
          nowCompleted
        )
    }
}

object InterleavedComputation {

  /**
    * Create a new interleaved computation.
    *
    * @param startResultData The opening result data object prior to computation
    * @param referenceData Static data made available to all computation steps
    * @param steps The computation steps
    * @tparam ReferenceData Type of the static data made available to every step in the computation
    * @tparam ResultModel Type of the interleaved computation's (partial/complete) result
    * @return The new interleaved computation ready for execution
    */
  def apply[ReferenceData, ResultModel](
      startResultData: ResultModel,
      referenceData: ReferenceData,
      steps: List[MonitoredStep[ReferenceData, ResultModel]]
  ): InterleavedComputation[ReferenceData, ResultModel] =
    InterleavedComputation[ReferenceData, ResultModel](startResultData, referenceData, steps, 0.0, 0)
}
