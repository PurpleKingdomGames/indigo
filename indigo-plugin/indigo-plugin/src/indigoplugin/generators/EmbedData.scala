package indigoplugin.generators

import scala.util.matching.Regex

// import scala.annotation.tailrec

object EmbedData {

  sealed trait Mode
  object Mode {
    final case class AsEnum(extendsFrom: Option[String])               extends Mode
    case object AsMap                                                  extends Mode
    final case class AsCustom(present: List[List[DataType]] => String) extends Mode
  }

  // Has a standard format, first row is headers, first column is keys.
  // Strings delimited with single or double quotes preserve the delimited
  // value, the quotes are dropped, but the other kind of quote within that
  // string is kept.
  // Cells cannot be empty.
  def generate(
      moduleName: String,
      fullyQualifiedPackage: String,
      filePath: os.Path,
      delimiter: String,
      rowFilter: String => Boolean,
      embedMode: Mode
  ): os.Path => Seq[os.Path] = outDir => {

    val lines =
      if (!os.exists(filePath)) throw new Exception("Path to data file not found: " + filePath.toString())
      else {
        os.read.lines(filePath).filter(rowFilter)
      }

    val rows =
      lines.map(row => extractRowData(row, delimiter)).toList

    val dataFrame =
      DataFrame.fromRows(rows)

    val wd = outDir / Generators.OutputDirName

    os.makeDir.all(wd)

    val file = wd / s"$moduleName.scala"

    val contents =
      embedMode match {
        case Mode.AsEnum(extendsFrom) =>
          s"""package $fullyQualifiedPackage
          |
          |// DO NOT EDIT: Generated by Indigo.
          |${dataFrame.renderEnum(moduleName, extendsFrom)}
          |""".stripMargin

        case Mode.AsMap =>
          s"""package $fullyQualifiedPackage
          |
          |// DO NOT EDIT: Generated by Indigo.
          |${dataFrame.renderMap(moduleName)}
          |""".stripMargin

        case Mode.AsCustom(present) =>
          s"""package $fullyQualifiedPackage
          |
          |// DO NOT EDIT: Generated by Indigo.
          |${dataFrame.renderCustom(present)}
          |""".stripMargin

      }

    os.write.over(file, contents)

    Seq(file)
  }

  def extractRowData(row: String, delimiter: String): List[DataType] = {

    val cleanDelimiter: String =
      if (delimiter == "\\|") "|" else delimiter

    val cleanRow: String =
      row.trim match {
        case r if r.startsWith(cleanDelimiter) && r.endsWith(cleanDelimiter) =>
          r.drop(cleanDelimiter.length()).dropRight(cleanDelimiter.length())

        case r if r.startsWith(cleanDelimiter) =>
          r.drop(cleanDelimiter.length())

        case r if r.endsWith(cleanDelimiter) =>
          r.dropRight(cleanDelimiter.length())

        case r =>
          r
      }

    parse(delimiter)(cleanRow).map(_._1).collect {
      case d @ DataType.StringData(s, _) if s.nonEmpty => d
      case DataType.StringData(_, _)                   => DataType.NullData
      case d: DataType.BooleanData                     => d
      case d: DataType.DoubleData                      => d
      case d: DataType.IntData                         => d
      case DataType.NullData                           => DataType.NullData
    }
  }

  // A parser of things,
  // is a function from strings,
  // to a list of pairs
  // of things and strings.
  def parse(delimiter: String): String => List[(DataType, String)] = {
    val takeUpToDelimiter        = s"^(.*?)${delimiter}(.*)".r
    val takeMatchingSingleQuotes = s"^'(.*?)'${delimiter}(.*)".r
    val takeMatchingDoubleQuotes = s"""^\"(.*?)\"${delimiter}(.*)""".r

    (in: String) =>
      in match {
        case takeMatchingDoubleQuotes(take, left) =>
          List(DataType.decideType(take.trim) -> left) ++ parse(delimiter)(left.trim)

        case takeMatchingSingleQuotes(take, left) =>
          List(DataType.decideType(take.trim) -> left) ++ parse(delimiter)(left.trim)

        case takeUpToDelimiter(take, left) =>
          List(DataType.decideType(take.trim) -> left) ++ parse(delimiter)(left.trim)

        case take =>
          List(DataType.decideType(take.trim) -> "")
      }
  }
}

sealed trait DataType {

  def nullable: Boolean
  def makeOptional: DataType

  def isString: Boolean =
    this match {
      case _: DataType.StringData => true
      case _                      => false
    }

  def isDouble: Boolean =
    this match {
      case _: DataType.DoubleData => true
      case _                      => false
    }

  def isInt: Boolean =
    this match {
      case _: DataType.IntData => true
      case _                   => false
    }

  def isBoolean: Boolean =
    this match {
      case _: DataType.BooleanData => true
      case _                       => false
    }

  def isNull: Boolean =
    this match {
      case DataType.NullData => true
      case _                 => false
    }

  def toStringData: DataType.StringData =
    this match {
      case s: DataType.StringData if s.nullable              => DataType.StringData(s"""Some("${s.value}")""", true)
      case s: DataType.StringData                            => s
      case DataType.BooleanData(value, nullable) if nullable => DataType.StringData(s"Some(${value.toString})", true)
      case DataType.BooleanData(value, _)                    => DataType.StringData(value.toString, false)
      case DataType.DoubleData(value, nullable) if nullable  => DataType.StringData(s"Some(${value.toString})", true)
      case DataType.DoubleData(value, _)                     => DataType.StringData(value.toString, false)
      case DataType.IntData(value, nullable) if nullable     => DataType.StringData(s"Some(${value.toString})", true)
      case DataType.IntData(value, _)                        => DataType.StringData(value.toString, false)
      case DataType.NullData                                 => DataType.StringData("None", true)
    }

  def asString: String =
    this match {
      case s: DataType.StringData if s.nullable              => s"""Some("${s.value}")"""
      case s: DataType.StringData                            => s""""${s.value}""""
      case DataType.BooleanData(value, nullable) if nullable => s"Some(${value.toString})"
      case DataType.BooleanData(value, _)                    => value.toString
      case DataType.DoubleData(value, nullable) if nullable  => s"Some(${value.toString})"
      case DataType.DoubleData(value, _)                     => value.toString
      case DataType.IntData(value, nullable) if nullable     => s"Some(${value.toString})"
      case DataType.IntData(value, _)                        => value.toString
      case DataType.NullData                                 => "None"
    }

  def giveTypeName: String =
    this match {
      case d: DataType.StringData if d.nullable  => "Option[String]"
      case _: DataType.StringData                => "String"
      case d: DataType.BooleanData if d.nullable => "Option[Boolean]"
      case _: DataType.BooleanData               => "Boolean"
      case d: DataType.DoubleData if d.nullable  => "Option[Double]"
      case _: DataType.DoubleData                => "Double"
      case d: DataType.IntData if d.nullable     => "Option[Int]"
      case _: DataType.IntData                   => "Int"
      case DataType.NullData                     => "Option[Any]"
    }

}
object DataType {

  // Most to least specific: Boolean, Int, Double, String
  final case class BooleanData(value: Boolean, nullable: Boolean) extends DataType {
    def makeOptional: BooleanData = this.copy(nullable = true)
  }
  object BooleanData {
    def apply(value: Boolean): BooleanData = BooleanData(value, false)
  }

  final case class IntData(value: Int, nullable: Boolean) extends DataType {
    def toDoubleData: DoubleData = DoubleData(value.toDouble, nullable)
    def makeOptional: IntData    = this.copy(nullable = true)
  }
  object IntData {
    def apply(value: Int): IntData = IntData(value, false)
  }

  final case class DoubleData(value: Double, nullable: Boolean) extends DataType {
    def makeOptional: DoubleData = this.copy(nullable = true)
  }
  object DoubleData {
    def apply(value: Double): DoubleData = DoubleData(value, false)
  }

  final case class StringData(value: String, nullable: Boolean) extends DataType {
    def makeOptional: StringData = this.copy(nullable = true)
  }
  object StringData {
    def apply(value: String): StringData = StringData(value, false)
  }

  case object NullData extends DataType {
    val nullable: Boolean      = true
    def makeOptional: DataType = this
  }

  private val isBoolean: Regex = """^(true|false)$""".r
  private val isInt: Regex     = """^(\-?[0-9]+)$""".r
  private val isDouble: Regex  = """^(\-?[0-9]+?)\.([0-9]+)$""".r
  private val isNull: Regex    = """^$""".r

  def decideType: String => DataType = {
    case isBoolean(v)     => BooleanData(v.toBoolean, false)
    case isInt(v)         => IntData(v.toInt, false)
    case isDouble(v1, v2) => DoubleData(s"$v1.$v2".toDouble, false)
    case isNull(_)        => NullData
    case v                => StringData(v, false)
  }

  def sameType(a: DataType, b: DataType): Boolean =
    (a, b) match {
      case (_: DataType.StringData, _: DataType.StringData)   => true
      case (DataType.NullData, _: DataType.StringData)        => true
      case (_: DataType.StringData, DataType.NullData)        => true
      case (_: DataType.BooleanData, _: DataType.BooleanData) => true
      case (DataType.NullData, _: DataType.BooleanData)       => true
      case (_: DataType.BooleanData, DataType.NullData)       => true
      case (_: DataType.DoubleData, _: DataType.DoubleData)   => true
      case (DataType.NullData, _: DataType.DoubleData)        => true
      case (_: DataType.DoubleData, DataType.NullData)        => true
      case (_: DataType.IntData, _: DataType.IntData)         => true
      case (DataType.NullData, _: DataType.IntData)           => true
      case (_: DataType.IntData, DataType.NullData)           => true
      case _                                                  => false
    }

  def allSameType(l: List[DataType]): Boolean =
    l match {
      case Nil    => true
      case h :: t => t.forall(d => sameType(h, d))
    }

  def allNumericTypes(l: List[DataType]): Boolean =
    l.forall(d => d.isDouble || d.isInt || d.isNull)

  def hasOptionalValues(l: List[DataType]): Boolean =
    l.contains(DataType.NullData)

  def convertToBestType(l: List[DataType]): List[DataType] =
    // Cases we can manage:
    // - They're all the same! Maybe optional...
    // - Doubles and Ints, convert Ints to Doubles
    // - Fallback is that everything is a string.
    if (allSameType(l)) {
      // All the same! Great!
      l
    } else if (allNumericTypes(l)) {
      l.map {
        case v @ DataType.DoubleData(_, _) => v
        case v @ DataType.IntData(_, _)    => v.toDoubleData
        case DataType.NullData             => DataType.NullData
        case s => throw new Exception(s"Unexpected non-numeric type '$s'") // Shouldn't get here.
      }
    } else {
      // Nothing else to do, but make everything a string that isn't null.
      l.map {
        case DataType.NullData => DataType.NullData
        case d                 => d.toStringData
      }
    }

  def matchHeaderRowLength(rows: Array[Array[DataType]]): Array[Array[DataType]] =
    rows.toList match {
      case Nil =>
        rows

      case headers :: data =>
        val l = headers.length
        val res =
          headers :: data.map { r =>
            val diff = l - r.length
            if (diff > 0) {
              r ++ List.fill(diff)(DataType.NullData)
            } else {
              r
            }
          }

        res.toArray
    }

}

final case class DataFrame(data: Array[Array[DataType]], columnCount: Int) {
  def headers: Array[DataType.StringData] =
    data.head.map(_.toStringData)

  def rows: Array[Array[DataType]] =
    data.tail

  def alignColumnTypes: DataFrame = {
    val columns =
      DataType.matchHeaderRowLength(rows).transpose

    val stringKeys: Array[DataType] =
      columns.head.map(_.toStringData)

    val typedColumns: Array[Array[DataType]] = columns.tail
      .map(d => DataType.convertToBestType(d.toList).toArray)

    val optionalColumns: Array[Array[DataType]] =
      typedColumns.map { col =>
        if (DataType.hasOptionalValues(col.toList)) {
          col.map(_.makeOptional)
        } else {
          col
        }
      }

    val cleanedRows: Array[Array[DataType]] =
      (stringKeys +: optionalColumns).transpose

    this.copy(
      data = headers.asInstanceOf[Array[DataType]] +: cleanedRows
    )
  }

  def toSafeName: String => String = { name: String =>
    name.replaceAll("[^a-zA-Z0-9]", "-").split("-").toList.filterNot(_.isEmpty) match {
      case h :: t if h.take(1).matches("[0-9]") => ("_" :: h :: t.map(_.capitalize)).mkString
      case l                                    => l.map(_.capitalize).mkString
    }
  }

  def toSafeNameCamel: String => String = { name: String =>
    name.replaceAll("[^a-zA-Z0-9]", "-").split("-").toList.filterNot(_.isEmpty) match {
      case h :: t if h.take(1).matches("[0-9]") => ("_" :: h :: t.map(_.capitalize)).mkString
      case h :: t                               => (h.toLowerCase :: t.map(_.capitalize)).mkString
      case l                                    => l.map(_.capitalize).mkString
    }
  }

  def renderVars(omitVal: Boolean): String = {
    val names = headers.drop(1).map(_.value)
    val types = rows.head.drop(1).map(_.giveTypeName)
    names
      .zip(types)
      .map { case (n, t) =>
        (if (omitVal) "" else "val ") + s"${toSafeNameCamel(n)}: $t"
      }
      .mkString(", ")
  }

  def renderEnum(moduleName: String, extendsFrom: Option[String]): String = {
    val renderedRows =
      rows
        .map { r =>
          s"""  case ${toSafeName(r.head.asString)} extends $moduleName(${r.tail
            .map(_.asString)
            .mkString(", ")})"""
        }
        .mkString("\n")

    val extFrom = extendsFrom
      .map { module =>
        s""" extends $module"""
      }
      .getOrElse("")

    s"""
    |enum $moduleName(${renderVars(false)})$extFrom:
    |${renderedRows}
    |""".stripMargin
  }

  def renderMap(moduleName: String): String = {
    val renderedRows =
      rows
        .map { r =>
          s"""      ${r.head.asString} -> $moduleName(${r.tail.map(_.asString).mkString(", ")})"""
        }
        .mkString(",\n")

    s"""
    |final case class $moduleName(${renderVars(true)})
    |object $moduleName:
    |  val data: Map[String, $moduleName] =
    |    Map(
    |${renderedRows}
    |    )
    |""".stripMargin
  }

  def renderCustom(present: List[List[DataType]] => String): String =
    present(headers.toList :: rows.map(_.toList).toList)
}
object DataFrame {

  private val standardMessage: String =
    "Embedded data must have two rows (minimum) of the same length (two columns minimum). The first row is the headers / field names. The first column are the keys."

  def fromRows(rows: List[List[DataType]]): DataFrame =
    rows match {
      case Nil =>
        throw new Exception("No data to create. " + standardMessage)

      case _ :: Nil =>
        throw new Exception("Only one row of data found. " + standardMessage)

      case h :: _ =>
        val len = h.length

        if (len == 0) {
          throw new Exception("No data to create. " + standardMessage)
        } else if (len == 1) {
          throw new Exception("Only one column of data. " + standardMessage)
        } else {
          DataFrame(rows.map(_.toArray).toArray, len).alignColumnTypes
        }
    }

}
