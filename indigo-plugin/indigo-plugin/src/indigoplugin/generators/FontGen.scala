package indigoplugin.generators

import scala.annotation.tailrec

object FontGen {

  def generate(
      moduleName: String,
      fullyQualifiedPackage: String,
      fontKey: String,
      fontFilePath: os.Path,
      fontSize: Int,
      charactersPerLine: Int,
      defaultChar: Char,
      chars: List[Char]
  ): os.Path => Seq[os.Path] = outDir => {

    val wd = outDir / Generators.OutputDirName

    os.makeDir.all(wd)

    val file = wd / s"$moduleName.scala"

    val helper = AWTStuff.makeHelper(fontFilePath.toIO, fontSize)

    // Process into laid out details
    val charDetails =
      layout(
        chars
          .map { c =>
            val (w, h, a) = helper.getCharBounds(c)
            CharDetail(c, 0, 0, w, h, a)
          },
        helper.getBaselineOffset,
        charactersPerLine
      )

    // Write out FontInfo
    val default =
      charDetails
        .find(_.char == defaultChar)
        .getOrElse(throw new Exception(s"Couldn't find default character '${defaultChar.toString}'"))

    val (sheetWidth, sheetHeight) = findBounds(charDetails)
    val fontInfo =
      genFontInfo(moduleName, fullyQualifiedPackage, fontKey, sheetWidth, sheetHeight, default, charDetails)

    os.write.over(file, fontInfo)

    // Write out font image
    val outImageFileName = sanitiseName(fontKey, "png")

    helper.drawFontSheet((wd / outImageFileName).toIO, charDetails, sheetWidth, sheetHeight)

    Seq(
      file,
      wd / outImageFileName
    )
  }

  def sanitiseName(name: String, ext: String): String = {
    val noExt = if (ext.nonEmpty && name.endsWith(ext)) name.dropRight(ext.length) else name
    noExt.replaceAll("[^A-Za-z0-9]", "-").split("-").map(_.capitalize).mkString
  }

  // TODO: Does nothing
  def layout(unplacedChars: List[CharDetail], lineSpacing: Int, maxCharsPerLine: Int): List[CharDetail] = {
    @tailrec
    def rec(
        remaining: List[CharDetail],
        lineCount: Int,
        charCount: Int,
        nextX: Int,
        acc: List[CharDetail]
    ): List[CharDetail] =
      remaining match {
        case Nil =>
          acc.reverse

        case c :: cs if charCount == maxCharsPerLine =>
          rec(c :: cs, lineCount + 1, 0, 0, acc)

        case c :: cs =>
          val x    = nextX
          val y    = lineCount * lineSpacing
          val newC = c.copy(x = x, y = y)

          rec(cs, lineCount, charCount + 1, nextX + c.width, newC :: acc)
      }

    rec(unplacedChars, 0, 0, 0, Nil)
  }

  def findBounds(charDetails: List[CharDetail]): (Int, Int) =
    charDetails.foldLeft((0, 0)) { case ((w, h), c) =>
      (
        if (c.x + c.width > w) c.x + c.width else w,
        if (c.y + c.height > h) c.y + c.height else h
      )
    }

  def genFontInfo(
      moduleName: String,
      fullyQualifiedPackage: String,
      name: String,
      sheetWidth: Int,
      sheetHeight: Int,
      default: CharDetail,
      chars: List[CharDetail]
  ): String = {

    val charString = chars
      .map(cd => "          " + toFontChar(cd) + ",")
      .mkString("\n")
      .dropRight(1) // Drops the last ','

    s"""package $fullyQualifiedPackage
    |
    |// DO NOT EDIT: Generated by Indigo.
    |object $moduleName:
    |
    |  val fontKey: FontKey = FontKey("$name")
    |
    |  val fontInfo: FontInfo =
    |    FontInfo(
    |      fontKey,
    |      $sheetWidth,
    |      $sheetHeight,
    |      FontChar("${default.char.toString()}", 0, 0, ${default.width.toString}, ${default.height.toString})
    |    ).isCaseSensitive
    |      .addChars(
    |        Batch(
    |$charString
    |        )
    |      )
    |}
    |""".stripMargin
  }

  def toFontChar(
      charDetail: CharDetail
  ): String = {
    val c = charDetail.char.toString()
    val x = charDetail.x.toString()
    val y = charDetail.y.toString()
    val w = charDetail.width.toString()
    val h = charDetail.height.toString()

    s"""FontChar("$c", $x, $y, $w, $h)"""
  }

}

final case class CharDetail(char: Char, x: Int, y: Int, width: Int, height: Int, ascent: Int)

object AWTStuff {

  import java.awt._
  import java.awt.image._
  import java.io._
  import javax.imageio.ImageIO

  def makeHelper(fontFile: File, fontSize: Int): Helper = {
    val font =
      Font
        .createFont(Font.TRUETYPE_FONT, fontFile)
        .deriveFont(fontSize.toFloat)

    Helper(font)
  }

  final case class Helper(font: Font) {
    val color             = Color.WHITE
    val antiAlias         = false
    val charactersPerLine = 16

    def getCharBounds(char: Char): (Int, Int, Int) = {
      val tmpBuffer = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)

      val tmpG2d = tmpBuffer.createGraphics()
      tmpG2d.setFont(font)

      val fontMetrics = tmpG2d.getFontMetrics()

      val w = fontMetrics.charWidth(char)
      val h = fontMetrics.getHeight()
      val a = fontMetrics.getAscent()

      tmpG2d.dispose()

      (w, h, a)
    }

    def getBaselineOffset: Int = {
      val tmpBuffer = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)
      val tmpG2d    = tmpBuffer.createGraphics()
      tmpG2d.setFont(font)
      val fontMetrics = tmpG2d.getFontMetrics()

      fontMetrics.getLeading() + fontMetrics.getAscent() + fontMetrics.getDescent()
    }

    def drawFontSheet(
        outFile: File,
        charDetails: scala.collection.immutable.List[CharDetail],
        sheetWidth: Int,
        sheetHeight: Int
    ): Unit = {
      val bufferedImage = new BufferedImage(sheetWidth, sheetHeight, BufferedImage.TYPE_INT_ARGB)

      val g2d = bufferedImage.createGraphics()

      if (antiAlias) {
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
      }

      g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY)

      g2d.setFont(font)
      g2d.setColor(color)

      charDetails.foreach { c =>
        g2d.drawString(c.char.toString, c.x, c.y + c.ascent)
      }

      g2d.dispose()

      ImageIO.write(bufferedImage, "PNG", outFile)

      ()
    }

  }

}
