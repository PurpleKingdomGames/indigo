<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>Performance</title>
  
  
  <meta name="description" content="A 2D Pixel Art FP game engine for Scala."/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../img/indigo_logo_solid.svg"/>
  
  <link rel="icon" sizes="64x64" type="image/svg+xml" href="../../img/indigo_logo_solid.svg"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/custom.css" />
  <script src="../../helium/site/laika-helium.js"></script>
  
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    
  </div>

  <a class="image-link" href="../../"><img src="../../img/indigo_logo_solid_text.svg" alt="Homepage" title="Indigo" width="150" height="50"></a>

  <div class="row links">
    
    <a class="button-link" href="https://discord.gg/b5CD47g">Discord</a>
    
    <a class="button-link" href="/api">API</a>
    
    <a class="button-link" href="https://github.com/PurpleKingdomGames/indigo">Github</a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="button-link" href="https://discord.gg/b5CD47g">Discord</a>
    
    <a class="button-link" href="/api">API</a>
    
    <a class="button-link" href="https://github.com/PurpleKingdomGames/indigo">Github</a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../table-of-content/">Contents</a></li>
    <li class="level1 nav-header">Setup &amp; Configuration</li>
    <li class="level2 nav-leaf"><a href="../../01-quickstart/examples/">Examples, Demos, and References</a></li>
    <li class="level2 nav-leaf"><a href="../../01-quickstart/extensions-and-libs/">Extensions, Libraries, and Related Projects</a></li>
    <li class="level2 nav-leaf"><a href="../../01-quickstart/hello-indigo/">Hello, Indigo!</a></li>
    <li class="level2 nav-leaf"><a href="../../01-quickstart/project-templates/">Mill &amp; SBT Templates</a></li>
    <li class="level2 nav-leaf"><a href="../../01-quickstart/quickstart/">Quick start</a></li>
    <li class="level1 nav-header">Guides</li>
    <li class="level2 nav-leaf"><a href="../../02-guides/howto-custom-entity/">How to make a custom entity</a></li>
    <li class="level2 nav-leaf"><a href="../../02-guides/howto-fire-shader/">How to write a fire shader</a></li>
    <li class="level2 nav-leaf"><a href="../../02-guides/howto-hello-indigo-tyrian/">How to make a responsive UI using Tyrian</a></li>
    <li class="level2 nav-leaf"><a href="../../02-guides/howto-indigo-game/">Converting <code>IndigoSandbox</code> to <code>IndigoGame</code></a></li>
    <li class="level1 nav-header">Gameloop</li>
    <li class="level2 nav-leaf"><a href="../../03-gameloop/events/">Events</a></li>
    <li class="level2 nav-leaf"><a href="../../03-gameloop/frame-context/">Frame context</a></li>
    <li class="level2 nav-leaf"><a href="../../03-gameloop/outcome/">Outcome Type</a></li>
    <li class="level1 nav-header">Organisation</li>
    <li class="level2 nav-leaf"><a href="../../04-organisation/boot-and-start-up/">Boot &amp; Start Up</a></li>
    <li class="level2 nav-leaf"><a href="../../04-organisation/game-entry-points/">Game Entry Points</a></li>
    <li class="level2 nav-leaf"><a href="../../04-organisation/scene-management/">What are Scenes?</a></li>
    <li class="level2 nav-leaf"><a href="../../04-organisation/subsystems/">What SubSystems are</a></li>
    <li class="level1 nav-header">Platform &amp; IO</li>
    <li class="level2 nav-leaf"><a href="../../05-platform/assets/">Assets &amp; Asset Loading</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/configuration/">Game Configuration</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/cross-platform-publishing/">Cross Platform Publishing</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/importers/">File Importers</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/input-handling/">Input Handling</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/loading-and-saving-data/">Loading &amp; Saving Data</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/logging/">Logging</a></li>
    <li class="level2 nav-leaf"><a href="../../05-platform/networking/">Networking</a></li>
    <li class="level1 nav-header">Presentation</li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/animation/">Animation</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/audio/">Audio</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/boundaries/">Boundaries</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/cameras/">Cameras</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/clones-and-mutants/">Clones &amp; Mutants</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/depth/">Depth</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/layers/">Layers</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/lighting/">Lighting</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/materials/">Materials</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/primitives/">Primitives &amp; Building Blocks</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/scene-update-fragment/">SceneUpdateFragment</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/shapes/">Shapes</a></li>
    <li class="level2 nav-leaf"><a href="../../06-presentation/text-and-fonts/">Text &amp; Fonts</a></li>
    <li class="level1 nav-header">Shaders</li>
    <li class="level2 nav-leaf"><a href="../../07-shaders/blending/">Blending</a></li>
    <li class="level2 nav-leaf"><a href="../../07-shaders/constants/">Shader Constants, Variables, and Outputs</a></li>
    <li class="level2 nav-leaf"><a href="../../07-shaders/premultiplied-alpha/">Premultiplied Alpha</a></li>
    <li class="level2 nav-leaf"><a href="../../07-shaders/shaders-overview/">Shaders Overview</a></li>
    <li class="level1 nav-header">Time</li>
    <li class="level2 nav-leaf"><a href="../../08-time/gametime/">GameTime</a></li>
    <li class="level2 nav-leaf"><a href="../../08-time/signals/">Signals &amp; Signal Functions</a></li>
    <li class="level2 nav-leaf"><a href="../../08-time/time-varying-values/">Time Varying Values</a></li>
    <li class="level1 nav-header">UI Components</li>
    <li class="level2 nav-leaf"><a href="../../09-uicomponents/button/">Buttons</a></li>
    <li class="level2 nav-leaf"><a href="../../09-uicomponents/hit-area/">Hit Areas</a></li>
    <li class="level2 nav-leaf"><a href="../../09-uicomponents/input-field/">Input Fields</a></li>
    <li class="level2 nav-leaf"><a href="../../09-uicomponents/radio-button/">Radio Buttons</a></li>
    <li class="level2 nav-leaf"><a href="../../09-uicomponents/ui-components/">UI Components</a></li>
    <li class="level1 nav-header">Misc</li>
    <li class="level2 nav-leaf"><a href="../alternatives/">Alternatives to Indigo</a></li>
    <li class="level2 nav-leaf"><a href="../antipatterns/">Anti-Patterns</a></li>
    <li class="level2 nav-leaf"><a href="../glossary/">Glossary</a></li>
    <li class="level2 nav-leaf"><a href="../key-concepts/">Key Concepts</a></li>
    <li class="level2 nav-leaf"><a href="../model-viewmodel-view/">Model, ViewModel, &amp; View</a></li>
    <li class="level2 nav-leaf"><a href="../motivation-and-constraints/">Motivation &amp; Constraints</a></li>
    <li class="level2 nav-leaf"><a href="../pathfinding/">Path finding</a></li>
    <li class="level2 active nav-leaf"><a href="#">Performance</a></li>
    <li class="level2 nav-leaf"><a href="../prior-art/">Prior Art</a></li>
    <li class="level2 nav-leaf"><a href="../rendering-technology/">Rendering Technology</a></li>
    <li class="level1 nav-header">Physics</li>
    <li class="level2 nav-leaf"><a href="../../11-physics/physics-overview/">Physics Overview</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Performance</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#what-is-performance">What is performance?</a></li>
    <li class="level1 nav-node"><a href="#is-it-fast-enough">Is it fast enough?</a></li>
    <li class="level2 nav-leaf"><a href="#start-on-the-assumption-that-it-will-be-fast-enough">Start on the assumption that it will be fast enough</a></li>
    <li class="level2 nav-leaf"><a href="#one-weird-trick-to-grind-indigo-to-a-halt">One weird trick to grind Indigo to a halt</a></li>
    <li class="level1 nav-node"><a href="#how-to-get-more-speed">How to get more speed</a></li>
    <li class="level2 nav-leaf"><a href="#measure-twice-cut-once">Measure twice, cut once</a></li>
    <li class="level2 nav-leaf"><a href="#if-you-can-t-see-it-don-t-draw-it">If you can&#39;t see it, don&#39;t draw it</a></li>
    <li class="level2 nav-leaf"><a href="#render-batch-size">Render batch size</a></li>
    <li class="level2 nav-leaf"><a href="#automata">Automata</a></li>
    <li class="level2 nav-leaf"><a href="#use-clones">Use Clones</a></li>
    <li class="level2 nav-leaf"><a href="#cache-values">Cache values</a></li>
    <li class="level2 nav-leaf"><a href="#consider-the-cost-of-different-primitives">Consider the cost of different primitives</a></li>
    <li class="level2 nav-leaf"><a href="#faster-processing">Faster processing</a></li>
    <li class="level1 nav-leaf"><a href="#don-t-fear-mutability">Don&#39;t fear mutability</a></li>
  </ul>

  <p class="footer"></p>
</nav>


      <main class="content">

        <h1 id="performance" class="title">Performance</h1>
        
        <h2 id="what-is-performance" class="section"><a class="anchor-link left" href="#what-is-performance"><i class="icofont-laika link">&#xef71;</i></a>What is performance?</h2>
        <p><strong>Lets get one thing clear:</strong> Indigo is not the fastest 2D game engine out there. Not even close. We haven&#39;t checked but it might even be the slowest - who knows! Nonetheless, here&#39;s a little demo merrily chugging along at 60 frames per second (performance will no doubt vary by system spec):</p>
        <p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">&quot;The Cursed Pirate&quot;, as shown at <a href="https://twitter.com/Scalainthecity?ref_src=twsrc%5Etfw">@Scalainthecity</a>. A <a href="https://twitter.com/hashtag/gamedev?src=hash&amp;ref_src=twsrc%5Etfw">#gamedev</a> demo written in <a href="https://twitter.com/hashtag/Scala?src=hash&amp;ref_src=twsrc%5Etfw">#Scala</a> and rendered to WebGL. <a href="https://t.co/g02yYvviaD">pic.twitter.com/g02yYvviaD</a></p>&mdash; Dave Smith (@davidjamessmith) <a href="https://twitter.com/davidjamessmith/status/1225182606192447488?ref_src=twsrc%5Etfw">February 5, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
        <p>Performance is relative. When people talk about game engine performance, they are usually talking about how many things it can do at once.</p>
        <p>The way raw engine performance is typically achieved is by utilizing clever data structures, mutable data stores, reusing allocated memory to keep usage constant, insisting on never creating new objects, and utilizing multi-threading.</p>
        <p>All of that <em>can</em> lead to higher performance, but it takes careful management since your guarantees around runtime behavior are reduced, and bugs can occur.</p>
        <p>In order to bring performance up, Indigo itself does all this too. Where Indigo and normal game engines diverge is that while these techniques are used by Indigo under the covers, it is strongly discouraged at the API level. Why is that?</p>
        <p>What if you could build games with an expectation of no bugs? Games that you <em>know</em> work before you play them because you can bring to bear an advanced type system, refinement types, property based testing, TDD (without excessive mocking), and any other code quality tool you can think of?</p>
        <p>Couldn&#39;t developer productivity be considered a type of performance too? The design of Indigo is to take an engine performance hit at the API level, in order to increase developer performance (easy to reason about, easy to test) and game production efficiency.</p>
        <p><em>Please note: You&#39;re still going to have to play your game at some point. No automated test suite in the world will tell you if you&#39;ve made something fun or not!</em></p>
        
        <h2 id="is-it-fast-enough" class="section"><a class="anchor-link left" href="#is-it-fast-enough"><i class="icofont-laika link">&#xef71;</i></a>Is it fast enough?</h2>
        <p>Having establishing that you&#39;re never going to get <a href="https://www.unrealengine.com/en-US/blog/a-first-look-at-unreal-engine-5">a billion triangles</a> though Indigo - what can you expect? Is the performance &quot;good enough&quot;?</p>
        <p>Well, two slightly disappointing observations that we&#39;ve made about 2D games during Indigo&#39;s development:</p>
        <ol class="arabic">
          <li>Most 2D games on the market don&#39;t actually have that many elements on screen at any one time - there&#39;s only so much screen real estate available for use when you have no real perspective or depth. (Naturally there are exceptions)</li>
          <li>Most game logic is quite straight forward, and revolve around a few core mechanics. The complexity is in how the elements interact.</li>
        </ol>
        <p>With that in mind then: Indigo is fast enough that you should not have to do anything clever or special to be able to hit a respectable frame rate for simple games.</p>
        <p>That said, some games and game developers always have and always will push what can be done by the system and engine they run on to the edge of what is possible. If you do that with your game, you may need to roll up your sleeves and think of clever ways to solve problems efficiently, but it&#39;s a high quality problem.</p>
        
        <h3 id="start-on-the-assumption-that-it-will-be-fast-enough" class="section"><a class="anchor-link left" href="#start-on-the-assumption-that-it-will-be-fast-enough"><i class="icofont-laika link">&#xef71;</i></a>Start on the assumption that it will be fast enough</h3>
        <p>In general, you should start by assuming Indigo will be fast enough. Build your game using good functional programming practices, and write your tests.</p>
        <p>You should only consider changing things if it really isn&#39;t fast enough when you play / performance test it. Remember that it&#39;s always easier to make clean, well written code go faster, than trying to improve the performance of something messy.</p>
        
        <h3 id="one-weird-trick-to-grind-indigo-to-a-halt" class="section"><a class="anchor-link left" href="#one-weird-trick-to-grind-indigo-to-a-halt"><i class="icofont-laika link">&#xef71;</i></a>One weird trick to grind Indigo to a halt</h3>
        <p>Try and render 1000 standard primitives of any type.</p>
        <p>Is 1000 a lot? It depends on what you&#39;re trying to render. If you want to render a standard roguelike map of 80x50 with every tile full - 4000 tiles - then it&#39;s not nearly enough! If you&#39;re rendering a little platform then 1000 is probably ample.</p>
        
        <h2 id="how-to-get-more-speed" class="section"><a class="anchor-link left" href="#how-to-get-more-speed"><i class="icofont-laika link">&#xef71;</i></a>How to get more speed</h2>
        <p>Depending on what kind of things you&#39;re doing, you can make Indigo do more in less time.</p>
        <p>Indigo is single threaded and runs in the browser. JavaScript code execution these days is very fast (currently Chrome/V8 is fastest), and your game logic draining CPU power is probably not a concern, nor is available memory.</p>
        <p><strong>Your main enemy in the quest for performance is memory allocation and subsequent garbage collection pauses.</strong></p>
        <p>The near universal mantra of game developers is to never allocate memory, i.e. create new objects, during a frame. Ever. Reuse, reuse, reuse. Unfortunately, Indigo is built on Scala offering up an immutable API, so we&#39;re going to be making new objects <em>all the time</em>.</p>
        <p>Generally your performance will suffer the more things you add to the screen. Our goal is to get the same effect you get by adding lots of things, but by doing less work. Here are a few tips for squeezing out some extra juice.</p>
        
        <h3 id="measure-twice-cut-once" class="section"><a class="anchor-link left" href="#measure-twice-cut-once"><i class="icofont-laika link">&#xef71;</i></a>Measure twice, cut once</h3>
        <blockquote>Be Aware: Running profiling tooling is, itself, expensive! You&#39;re game might do 58 FPS normally and 47 under profiling. Try plugging in the FPS Counter <code>SubSystem</code> for another view.</blockquote>
        <p>Modern browsers have amazing profiling tools built into them these days. Get to know them by recording the performance of your running game, and then look for evidence of where you&#39;re creating things like GC pauses or large numbers of allocations, and try to track down the culprit code.</p>
        <p>If you aren&#39;t improving the slowest bottleneck of your game code, you aren&#39;t improving anything.</p>
        <blockquote>Tip: In Firefox make sure you check the &quot;Record Allocations&quot; setting in the performance tab.</blockquote>
        
        <h3 id="if-you-can-t-see-it-don-t-draw-it" class="section"><a class="anchor-link left" href="#if-you-can-t-see-it-don-t-draw-it"><i class="icofont-laika link">&#xef71;</i></a>If you can&#39;t see it, don&#39;t draw it</h3>
        <p>Normally when you create a game element like a sprite in a conventional game engine, they hang around until you remove them. Indigo only draws what your <code>SceneUpdateFragment</code> describes <strong>right now</strong>. As such, Indigo assumes you know what you&#39;re doing and doesn&#39;t try to do any clever interpretation of your scene*.</p>
        <blockquote>*Culling at the render level will occur, but that won&#39;t prevent the processing of your scene elements.</blockquote>
        <p>Normal practice is to perform <a href="https://en.wikipedia.org/wiki/Viewing_frustum">&quot;Viewing-frustum culling&quot;</a> to remove things that aren&#39;t visible on the screen i.e it&#39;s &quot;off camera&quot;.</p>
        
        <h3 id="render-batch-size" class="section"><a class="anchor-link left" href="#render-batch-size"><i class="icofont-laika link">&#xef71;</i></a>Render batch size</h3>
        <blockquote>WebGL 2.0 only!</blockquote>
        <p>There is a batch size option in the main game config that you can tweak, it relates to the maximum number of renderable items that are bundled up before a draw call is issued. It&#39;s a trade off: Bigger batches mean more memory usage but fewer calls to the graphics card.</p>
        <p>In general fiddling will only affect games with a lot of scene elements.</p>
        
        <h3 id="automata" class="section"><a class="anchor-link left" href="#automata"><i class="icofont-laika link">&#xef71;</i></a>Automata</h3>
        <p>Automata are great fun, and a very convenient way to manage and program short lived little entities with simple life cycles e.g. the points that appear above a characters head when they pick up a coin.</p>
        <p>However, they can allocate relatively large amounts of memory because the structures they use to make them fun to use, are <em>not</em> the most light weight way to solve the problem. As a rule of thumb: A few hundred are probably fine.</p>
        
        <h4 id="tweak-the-pool-size" class="section"><a class="anchor-link left" href="#tweak-the-pool-size"><i class="icofont-laika link">&#xef71;</i></a>Tweak the pool size</h4>
        <p>A simple way to improve performance of automata - depending on the circumstances - is to reduce the default pool size (<code>None</code> by default) that controls how many automaton instances can be alive at any one time. If your effect isn&#39;t mission critical, try limiting the pool size.</p>
        
        <h4 id="subsystems-vs-automata" class="section"><a class="anchor-link left" href="#subsystems-vs-automata"><i class="icofont-laika link">&#xef71;</i></a>SubSystems vs Automata</h4>
        <p>The Automata system is just a SubSystem. If you need simple particles in high volumes and are prepared to manage the state yourself, you can write much leaner code by hand crafting a <code>SubSystem</code>, especially in combination with clones.</p>
        
        <h3 id="use-clones" class="section"><a class="anchor-link left" href="#use-clones"><i class="icofont-laika link">&#xef71;</i></a>Use Clones</h3>
        <blockquote>WebGL 2.0 only!</blockquote>
        <p>Clones are Indigo&#39;s version of what is known as &quot;instancing&quot;. Say you want to render lots (lots and lots and lots!) of things that are more or less identical, such as blades of grass or tiles in a tile map, you should consider using clones.</p>
        <p>With clones, you set up a reference object (that you can update as normal), and then tell indigo to render many more of them. This shortcuts a lot of processing in the pipeline and allows for vast numbers of copies to be drawn at the cost of a lack of variety, although a limited set of properties can be changed.</p>
        <p>Clone batches can also be declared static for even more performance, if they never change.</p>
        <p>A recent test ran 210,000 animated clones at 60fps alongside other screen elements, which would not be possible with other types of primitives.</p>
        
        <h3 id="cache-values" class="section"><a class="anchor-link left" href="#cache-values"><i class="icofont-laika link">&#xef71;</i></a>Cache values</h3>
        <p>May seem obvious but some values are just expensive to work out. Object boundaries for example, particularly text boundaries or groups with many elements, can be quite expensive to calculate. If you (as the game programmer) know that a value is going to be used a lot but is never going to need to be recalculated, consider storing it and looking it up next time. In the example of boundaries, a good place to store it might be as part of the view model.</p>
        
        <h3 id="consider-the-cost-of-different-primitives" class="section"><a class="anchor-link left" href="#consider-the-cost-of-different-primitives"><i class="icofont-laika link">&#xef71;</i></a>Consider the cost of different primitives</h3>
        <p>Different types of primitives have different costs, here they are ranked from cheapest to (potentially) most expensive:</p>
        <ol class="arabic">
          <li>CloneBatch/CloneTiles - Unintelligent copies of things.</li>
          <li>Graphic - bounds require no calculation, they have no clever inner workings and process no events.</li>
          <li>Clip - again, bounds require no calculation, they have no clever inner workings and process no events.</li>
          <li>Sprite - processes events, has animation state to update, bounds must be recalculated each time.</li>
          <li>Text - no state, render time varies a lot, but processes events which are based on very expensive bounds calculations.</li>
          <li>TextBox - no state, but processes events which are based on very expensive bounds calculations.</li>
          <li>Group - no state, no events, but bounds calculation is based on the contents - so can be big.</li>
        </ol>
        
        <h4 id="reuse-animations" class="section"><a class="anchor-link left" href="#reuse-animations"><i class="icofont-laika link">&#xef71;</i></a>Reuse animations</h4>
        <p>One way to reduce the cost of animated elements is to reuse them!</p>
        <p><strong>Example scenario:</strong> You have a number of background elements, and it&#39;s acceptable for all of them to be on the same animation loop at the exact same frame position (e.g. you have a forest and 25% of the trees are identical), but you want to be able to interact with them individually (thus ruling out clones).</p>
        <ol class="arabic">
          <li>Establish a master sprite;</li>
          <li>Give all of the sprites the same animation key;</li>
          <li>Only update the animation of the master sprite;</li>
          <li>All the others will be animated identically but with no additional event or animation processing cost.</li>
        </ol>
        
        <h4 id="animate-with-clips" class="section"><a class="anchor-link left" href="#animate-with-clips"><i class="icofont-laika link">&#xef71;</i></a>Animate with Clips</h4>
        <p>If possible, swap Sprites for Clips which are much cheaper to run.</p>
        
        <h4 id="manually-cache-groups" class="section"><a class="anchor-link left" href="#manually-cache-groups"><i class="icofont-laika link">&#xef71;</i></a>Manually cache groups</h4>
        <blockquote>There is an <a href="https://github.com/PurpleKingdomGames/indigo/issues/4">open issue</a> to look into formal ways to speed up static groups.</blockquote>
        <p>If you have a big <code>Group</code> of static things, consider caching it in your view model and reusing it.</p>
        
        <h4 id="manually-accept-interactions-on-graphics" class="section"><a class="anchor-link left" href="#manually-accept-interactions-on-graphics"><i class="icofont-laika link">&#xef71;</i></a>Manually accept interactions on Graphics</h4>
        <p>Graphics do not accept events / interactions in the same way that Sprites and Text do. This is to reduce the processing cost of graphics, since event handling can be ignored for <code>Graphic</code>s during the scene graph traversal, allowing you to have a lot more of them on the screen.</p>
        <p>For one off interactive elements though, you can avoid using a Sprite by mimicking the event handler behavior manually. For example, you can check the mouse position and whether or not it was clicked within graphic node&#39;s very cheap to calculate bounds during the view presentation function.</p>
        
        <h3 id="faster-processing" class="section"><a class="anchor-link left" href="#faster-processing"><i class="icofont-laika link">&#xef71;</i></a>Faster processing</h3>
        <p>In terms of view processing, memory allocations are typically the problem, but you can also experience CPU bottlenecks depending on the kind of game you&#39;re building.</p>
        
        <h4 id="use-appropriate-data-structures" class="section"><a class="anchor-link left" href="#use-appropriate-data-structures"><i class="icofont-laika link">&#xef71;</i></a>Use appropriate data structures</h4>
        <p>In many cases, a simple array of things to process will do. However, just as an example, if you&#39;re processing something spacial like collision detection or available moves on large playing grid, you should look for data structures that can efficiently ignore / avoid processing irrelevant areas, such as a <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">BSP</a> or <a href="https://en.wikipedia.org/wiki/Quadtree">Quadtree</a> structures.</p>
        
        <h4 id="use-updatelist" class="section"><a class="anchor-link left" href="#use-updatelist"><i class="icofont-laika link">&#xef71;</i></a>Use <code>UpdateList</code></h4>
        <p>Split expensive calculation work over multiple frames.</p>
        <p><strong>Scenario:</strong></p>
        <p>You&#39;re writing a farming game and have a massive grid of crops to update. You can certainly reduce the drawing overhead using some of the techniques previously mentioned, but what about updating them all?</p>
        <p>To help with the time element, you could use a <code>TimeVaryingValue</code> that will automatically advance the value of the crops for a given time. However, updating all the elements is expensive - perhaps your calculation has to decide what&#39;s happening to the crop based on many environmental conditions?</p>
        <p>If you wrap your crops up in an <code>UpdateList</code> you can specific an update pattern, for example you could update 25% of the crops this frame, and 25% on each of the next three subsequent frames until they&#39;re all done. As long as your calculation is time based, and the accuracy of when you need to know the crops are ready is acceptable to be within 4 frames of the actual completion time, you can quarter your per frame processing costs.</p>
        <p>Note that you&#39;re still allocating for the whole grid in this scenario! Consider combining these with better data structures as discussed above for further gains.</p>
        
        <h2 id="don-t-fear-mutability" class="section"><a class="anchor-link left" href="#don-t-fear-mutability"><i class="icofont-laika link">&#xef71;</i></a>Don&#39;t fear mutability</h2>
        <p>Your last angle of attack is to use mutable data and imperative programming techniques.</p>
        <p>Scala is an impure functional language and there is nothing wrong with taking advantage of that. You should always pull for purity and immutability first, but games by their very nature are always pushing the resource constraints of their system in one way or another, and finding game performance is about making trade-offs. <em>Sometimes</em> the trade off is your purely functional sensibilities!</p>
        <p>If you&#39;ve measured and identified an area of your code that is causing a bottleneck, <em>sometimes</em> the best solution is to roll up your sleeves and use a more imperative solution to do a bit of specific, localized, optimization. <strong><em>Never ever</em></strong> do this without profiling your code first, or you&#39;re probably wasting your time.</p>
        <p>Remember, a function is pure and referentially transparent as long as for a given set of arguments you always get the same result - there are no limits on how you make that happen. Using a while loop and a var is not against the rules! Just write good tests, and use strong encapsulation.</p>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>