<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Performance · Indigo</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## What is performance?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Performance · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="## What is performance?"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="Indigo Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="Indigo Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/docs/guides" target="_self">Guides</a></li><li class="siteNavGroupActive"><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="/api/api/indigo.html" target="_self">APIs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Other information</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Indigo</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/development-status">Indigo&#x27;s Development Status</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/quickstart/setup-and-configuration">Setup &amp; Configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/hello-indigo">Hello, Indigo!</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/examples">Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/project-templates">Mill &amp; SBT Game Templates</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Organising your game</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/organisation/boot-and-start-up">Boot &amp; Start Up</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/game-entry-points">Game Entry Points</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/scene-management">Scenes &amp; Scene Management</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/subsystems">SubSystems</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">The game loop</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gameloop/events">Events</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/frame-context">Frame context</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/outcome">Outcome Type</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Presentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/presentation/animation">Animation</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/audio">Audio</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/cameras">Cameras</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/depth-and-layers">Depth &amp; Layers</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/materials">Materials</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/primitives">Primitives &amp; Building Blocks</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/scene-update-fragment">SceneUpdateFragment</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/text-and-fonts">Text &amp; Fonts</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/ui-components">UI Components</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shaders</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/shaders/shader-overview">Shaders Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/constants">Shader Constants, Variables, and Outputs</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/entity-shaders">Entity Shaders</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/blending">Blending</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Working with Time</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/time/signals">Signals &amp; Signal Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/time/time-varying-values">Time Varying Values</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Platform &amp; Publishing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/platform/assets">Assets &amp; Asset Loading</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/cross-platform-publishing">Cross Platform Publishing</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/importers">File Format Importers</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/input-handling">User Input Handling</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/loading-and-saving-data">Loading &amp; Saving Data</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/networking">Networking</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other information</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/information/alternatives">Alternatives to Indigo</a></li><li class="navListItem"><a class="navItem" href="/docs/information/glossary">Glossary</a></li><li class="navListItem"><a class="navItem" href="/docs/information/key-concepts">Key Concepts</a></li><li class="navListItem"><a class="navItem" href="/docs/information/model-viewmodel-view">Model, ViewModel, &amp; View</a></li><li class="navListItem"><a class="navItem" href="/docs/information/motivation-and-constraints">Motivation &amp; Constraints</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/information/performance">Performance</a></li><li class="navListItem"><a class="navItem" href="/docs/information/prior-art">Prior Art</a></li><li class="navListItem"><a class="navItem" href="/docs/information/rendering-technology">Rendering Technology</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Performance</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="what-is-performance"></a><a href="#what-is-performance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is performance?</h2>
<p><strong>Lets get one thing clear:</strong> Indigo is not the fastest 2D game engine out there. Not even close. We haven't checked but it might even be the slowest - who knows! Nonetheless, here's a little demo merrily chugging along at 60 frames per second (performance will no doubt vary by system spec):</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">&quot;The Cursed Pirate&quot;, as shown at <a href="https://twitter.com/Scalainthecity?ref_src=twsrc%5Etfw">@Scalainthecity</a>. A <a href="https://twitter.com/hashtag/gamedev?src=hash&amp;ref_src=twsrc%5Etfw">#gamedev</a> demo written in <a href="https://twitter.com/hashtag/Scala?src=hash&amp;ref_src=twsrc%5Etfw">#Scala</a> and rendered to WebGL. <a href="https://t.co/g02yYvviaD">pic.twitter.com/g02yYvviaD</a></p>&mdash; Dave Smith (@davidjamessmith) <a href="https://twitter.com/davidjamessmith/status/1225182606192447488?ref_src=twsrc%5Etfw">February 5, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>Performance is relative. When people talk about game engine performance, they are usually talking about how many things it can do at once.</p>
<p>The way raw engine performance is typically achieved is by utilizing clever data structures, mutable data stores, reusing allocated memory to keep usage constant, insisting on never creating new objects, and utilizing multi-threading.</p>
<p>All of that <em>can</em> lead to higher performance, but it takes careful management since your guarantees around runtime behavior are reduced, and bugs can occur.</p>
<p>In order to bring performance up, Indigo itself does all this too. Where Indigo and normal game engines diverge is that while these techniques are used by Indigo under the covers, it is strongly discouraged at the API level. Why is that?</p>
<p>What if you could build games with an expectation of no bugs? Games that you <em>know</em> work before you play them because you can bring to bear an advanced type system, refinement types, property based testing, TDD (without excessive mocking), and any other code quality tool you can think of?</p>
<p>Couldn't developer productivity be considered a type of performance too? The design of Indigo is to take an engine performance hit at the API level, in order to increase developer performance (easy to reason about, easy to test) and game production efficiency.</p>
<p><em>Please note: You're still going to have to play your game at some point. No automated test suite in the world will tell you if you've made something fun or not!</em></p>
<h2><a class="anchor" aria-hidden="true" id="is-it-fast-enough"></a><a href="#is-it-fast-enough" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is it fast enough?</h2>
<p>Having establishing that you're never going to get <a href="https://www.unrealengine.com/en-US/blog/a-first-look-at-unreal-engine-5">a billion triangles</a> though Indigo - what can you expect? Is the performance &quot;good enough&quot;?</p>
<p>Well, two slightly disappointing observations that we've made about 2D games during Indigo's development:</p>
<ol>
<li>Most 2D games on the market don't actually have that many elements on screen at any one time - there's only so much screen real estate available for use when you have no real perspective or depth. (Naturally there are exceptions)</li>
<li>Most game logic is quite straight forward, and revolve around a few core mechanics. The complexity is in how the elements interact.</li>
</ol>
<p>With that in mind then: Indigo is fast enough that you should not have to do anything clever or special to be able to hit a respectable frame rate for most games.</p>
<h3><a class="anchor" aria-hidden="true" id="start-on-the-assumption-that-it-will-be-fast-enough"></a><a href="#start-on-the-assumption-that-it-will-be-fast-enough" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Start on the assumption that it will be fast enough</h3>
<p>In general, you should start by assuming Indigo will be fast enough. Build your game using good functional programming practices, and write your tests.</p>
<p>You should only consider changing things if it really isn't fast enough when you play / performance test it. Remember that it's always easier to make clean, well written code go faster, than trying to improve the performance of something messy.</p>
<h3><a class="anchor" aria-hidden="true" id="one-weird-trick-to-grind-indigo-to-a-halt"></a><a href="#one-weird-trick-to-grind-indigo-to-a-halt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>One weird trick to grind Indigo to a halt</h3>
<p>Two sort of similar features that Indigo <em>does not</em> have are:</p>
<ol>
<li>GPU rendered particle systems;</li>
<li>Shader based effects like light trails.</li>
</ol>
<p>Both of these cases can only be simulated on the CPU side, and attempting to do so with very heavy numbers of &quot;particles&quot; will slow Indigo right down, particularly if you use a naive solution.</p>
<h2><a class="anchor" aria-hidden="true" id="how-to-get-more-speed"></a><a href="#how-to-get-more-speed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to get more speed</h2>
<p>Depending on what kind of things you're doing, you can make Indigo do more in less time.</p>
<p>Indigo is single threaded and runs in the browser. JavaScript code execution these days is very fast, and your game logic draining CPU power is probably not a concern, nor is available memory.</p>
<p><strong>Your main enemy in the quest for performance is memory allocation and subsequent garbage collection pauses.</strong></p>
<p>The near universal mantra of game developers is to never allocate memory, i.e. create new objects, during a frame. Ever. Reuse, reuse, reuse. Unfortunately, Indigo is built on Scala offering up an immutable API, so we're going to be making new objects <em>all the time</em>.</p>
<p>Generally your performance will suffer the more things you add to the screen. Our goal is to get the same effect you get by adding lots of things, but by doing less work. Here are a few tips for squeezing out some extra juice.</p>
<h3><a class="anchor" aria-hidden="true" id="measure-twice-cut-once"></a><a href="#measure-twice-cut-once" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Measure twice, cut once</h3>
<blockquote>
<p>Be Aware: Running profiling tooling is, itself, expensive! You're game might do 58 FPS normally and 47 under profiling. Try plugging in the FPS Counter <code>SubSystem</code> for another view.</p>
</blockquote>
<p>Modern browsers have amazing profiling tools built into them these days. Get to know them by recording the performance of your running game, and then look for evidence of where you're creating things like GC pauses or large numbers of allocations, and try to track down the culprit code.</p>
<p>If you aren't improving the slowest bottleneck of your game code, you aren't improving anything.</p>
<blockquote>
<p>Tip: In Firefox make sure you check the &quot;Record Allocations&quot; setting in the performance tab.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="if-you-cant-see-it-dont-draw-it"></a><a href="#if-you-cant-see-it-dont-draw-it" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>If you can't see it, don't draw it</h3>
<p>Normally when you create a game element like a sprite in a conventional game engine, they hang around until you remove them. Indigo only draws what your <code>SceneUpdateFragment</code> describes <strong>right now</strong>. As such, Indigo assumes you know what you're doing and doesn't try to do any clever interpretation of your scene*.</p>
<blockquote>
<p>*Culling at the render level will occur, but that won't prevent the processing of your scene elements.</p>
</blockquote>
<p>Normal practice is to perform <a href="https://en.wikipedia.org/wiki/Viewing_frustum">&quot;Viewing-frustum culling&quot;</a> to remove things that aren't visible on the screen i.e it's &quot;off camera&quot;.</p>
<h3><a class="anchor" aria-hidden="true" id="render-batch-size"></a><a href="#render-batch-size" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Render batch size</h3>
<blockquote>
<p>WebGL 2.0 only!</p>
</blockquote>
<p>There is a batch size option in the main game config that you can tweak, it relates to the maximum number of renderable items that are bundled up before a draw call is issued. It's a trade off: Bigger batches mean more memory usage but fewer calls to the graphics card.</p>
<p>In general fiddling will only affect games with a lot of scene elements.</p>
<h3><a class="anchor" aria-hidden="true" id="automata"></a><a href="#automata" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Automata</h3>
<p>Automata are great fun, and a very convenient way to manage and program short lived little entities with simple life cycles e.g. the points that appear above a characters head when they pick up a coin.</p>
<p>However, they can allocate relatively large amounts of memory because the structures they use to make them fun to use, are <em>not</em> the most light weight way to solve the problem. As a rule of thumb: A few hundred are probably fine.</p>
<h4><a class="anchor" aria-hidden="true" id="tweak-the-pool-size"></a><a href="#tweak-the-pool-size" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tweak the pool size</h4>
<p>A simple way to improve performance of automata - depending on the circumstances - is to reduce the default pool size (<code>None</code> by default) that controls how many automaton instances can be alive at any one time. If your effect isn't mission critical, try limiting the pool size.</p>
<h4><a class="anchor" aria-hidden="true" id="subsystems-vs-automata"></a><a href="#subsystems-vs-automata" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SubSystems vs Automata</h4>
<p>The Automata system is just a SubSystem. If you need simple particles in high volumes and are prepared to manage the state yourself, you can write much leaner code by hand crafting a <code>SubSystem</code>, especially in combination with clones.</p>
<h3><a class="anchor" aria-hidden="true" id="use-clones"></a><a href="#use-clones" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use Clones</h3>
<blockquote>
<p>WebGL 2.0 only!</p>
</blockquote>
<p>Clones are Indigo's version of what is known as &quot;instancing&quot;. Say you want to render lots (lots and lots and lots!) of things that are more or less identical, such as blades of grass or tiles in a tile map, you should consider using clones.</p>
<p>With clones, you set up a reference object (that you can update as normal), and then tell indigo to render many more of them. This shortcuts a lot of processing in the pipeline and allows for vast numbers of copies to be drawn at the cost of a lack of variety, although a limited set of properties can be changed.</p>
<p>Clone batches can also be declared static for even more performance, if they never change.</p>
<p>A recent test ran 10,000 animated clones at 60fps alongside other screen elements, which would not be possible with other types of primitives.</p>
<h3><a class="anchor" aria-hidden="true" id="cache-values"></a><a href="#cache-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cache values</h3>
<p>May seem obvious but some values are just expensive to work out. Object boundaries for example, particularly text boundaries or groups with many elements, can be quite expensive to calculate. If you (as the game programmer) know that a value is going to be used a lot but is never going to need to be recalculated, consider storing it and looking it up next time. In the example of boundaries, a good place to store it might be as part of the view model.</p>
<h3><a class="anchor" aria-hidden="true" id="consider-the-cost-of-different-primitives"></a><a href="#consider-the-cost-of-different-primitives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consider the cost of different primitives</h3>
<p>Different types of primitives have different costs, here they are ranked from cheapest to (potentially) most expensive:</p>
<ol>
<li>Clone - Unintelligent copies of things.</li>
<li>Graphic - bounds require no calculation, they have no clever inner workings and process no events.</li>
<li>Sprite - processes events, has animation state to update, bounds must be recalculated each time.</li>
<li>Text - no state, but processes events which are based on ver expensive bounds calculations.</li>
<li>Group - no state, no events, but bounds calculation is based on the contents - so can be big.</li>
</ol>
<h4><a class="anchor" aria-hidden="true" id="reuse-animations"></a><a href="#reuse-animations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reuse animations</h4>
<p>One way to reduce the cost of animated elements is to reuse them!</p>
<p><strong>Example scenario:</strong> You have a number of background elements, and it's acceptable for all of them to be on the same animation loop at the exact same frame position (e.g. you have a forest and 25% of the trees are identical), but you want to be able to interact with them individually (thus ruling out clones).</p>
<ol>
<li>Establish a master sprite;</li>
<li>Give all of the sprites the same animation key;</li>
<li>Only update the animation of the master sprite;</li>
<li>All the others will be animated identically but with no additional event or animation processing cost.</li>
</ol>
<h4><a class="anchor" aria-hidden="true" id="manually-cache-groups"></a><a href="#manually-cache-groups" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Manually cache groups</h4>
<blockquote>
<p>There is an <a href="https://github.com/PurpleKingdomGames/indigo/issues/4">open issue</a> to look into formal ways to speed up static groups.</p>
</blockquote>
<p>If you have a big <code>Group</code> of static things, consider caching it in your view model and reusing it.</p>
<h4><a class="anchor" aria-hidden="true" id="manually-accept-interactions-on-graphics"></a><a href="#manually-accept-interactions-on-graphics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Manually accept interactions on Graphics</h4>
<p>Graphics do not accept events / interactions in the same way that Sprites and Text do. This is to reduce the processing cost of graphics, since event handling can be ignored for <code>Graphic</code>s during the scene graph traversal, allowing you to have a lot more of them on the screen.</p>
<p>For one off interactive elements though, you can avoid using a Sprite by mimicking the event handler behavior manually. For example, you can check the mouse position and whether or not it was clicked within graphic node's very cheap to calculate bounds during the view presentation function.</p>
<h3><a class="anchor" aria-hidden="true" id="faster-processing"></a><a href="#faster-processing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Faster processing</h3>
<p>In terms of view processing, memory allocations are typically the problem, but you can also experience CPU bottlenecks depending on the kind of game you're building.</p>
<h4><a class="anchor" aria-hidden="true" id="use-appropriate-data-structures"></a><a href="#use-appropriate-data-structures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use appropriate data structures</h4>
<p>In many cases, a simple array of things to process will do. However, just as an example, if you're processing something spacial like collision detection or available moves on large playing grid, you should look for data structures that can efficiently ignore / avoid processing irrelevant areas, such as a <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">BSP</a> or <a href="https://en.wikipedia.org/wiki/Quadtree">Quadtree</a> structures.</p>
<h4><a class="anchor" aria-hidden="true" id="use-updatelist"></a><a href="#use-updatelist" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use <code>UpdateList</code></h4>
<p>Split expensive calculation work over multiple frames.</p>
<p><strong>Scenario:</strong></p>
<p>You're writing a farming game and have a massive grid of crops to update. You can certainly reduce the drawing overhead using some of the techniques previously mentioned, but what about updating them all?</p>
<p>To help with the time element, you could use a <code>TimeVaryingValue</code> that will automatically advance the value of the crops for a given time. However, updating all the elements is expensive - perhaps your calculation has to decide what's happening to the crop based on many environmental conditions?</p>
<p>If you wrap your crops up in an <code>UpdateList</code> you can specific an update pattern, for example you could update 25% of the crops this frame, and 25% on each of the next three subsequent frames until they're all done. As long as your calculation is time based, and the accuracy of when you need to know the crops are ready is acceptable to be within 4 frames of the actual completion time, you can quarter your per frame processing costs.</p>
<p>Note that you're still allocating for the whole grid in this scenario! Consider combining these with better data structures as discussed above for further gains.</p>
<h2><a class="anchor" aria-hidden="true" id="dont-fear-mutability"></a><a href="#dont-fear-mutability" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Don't fear mutability</h2>
<p>Your last angle of attack is to use mutable data and imperative programming techniques.</p>
<p>Scala is an impure functional language and there is nothing wrong with taking advantage of that. You should always pull for purity and immutability first, but games by their very nature are always pushing the resource constraints of their system in one way or another, and finding game performance is about making trade-offs. <em>Sometimes</em> the trade off is your purely functional sensibilities!</p>
<p>If you've measured and identified an area of your code that is causing a bottleneck, <em>sometimes</em> the best solution is to roll up your sleeves and use a more imperative solution to do a bit of specific, localized, optimization. <strong><em>Never ever</em></strong> do this without profiling your code first, or you're probably wasting your time.</p>
<p>Remember, a function is pure and referentially transparent as long as for a given set of arguments you always get the same result - there are no limits on how you make that happen. Using a while loop and a var is not against the rules! Just write good tests, and use strong encapsulation.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/information/motivation-and-constraints"><span class="arrow-prev">← </span><span>Motivation &amp; Constraints</span></a><a class="docs-next button" href="/docs/information/prior-art"><span>Prior Art</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-is-performance">What is performance?</a></li><li><a href="#is-it-fast-enough">Is it fast enough?</a><ul class="toc-headings"><li><a href="#start-on-the-assumption-that-it-will-be-fast-enough">Start on the assumption that it will be fast enough</a></li><li><a href="#one-weird-trick-to-grind-indigo-to-a-halt">One weird trick to grind Indigo to a halt</a></li></ul></li><li><a href="#how-to-get-more-speed">How to get more speed</a><ul class="toc-headings"><li><a href="#measure-twice-cut-once">Measure twice, cut once</a></li><li><a href="#if-you-cant-see-it-dont-draw-it">If you can't see it, don't draw it</a></li><li><a href="#render-batch-size">Render batch size</a></li><li><a href="#automata">Automata</a></li><li><a href="#use-clones">Use Clones</a></li><li><a href="#cache-values">Cache values</a></li><li><a href="#consider-the-cost-of-different-primitives">Consider the cost of different primitives</a></li><li><a href="#faster-processing">Faster processing</a></li></ul></li><li><a href="#dont-fear-mutability">Don't fear mutability</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a><a href="/docs/en/quickstart/project-templates">Project templates</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://github.com/PurpleKingdomGames/indigo/discussions">GitHub Discussons</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section></footer></div></body></html>