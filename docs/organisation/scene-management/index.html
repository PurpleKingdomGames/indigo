<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Scenes &amp; Scene Management · Indigo</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## What are Scenes?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Scenes &amp; Scene Management · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="## What are Scenes?"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="Indigo Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="Indigo Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/docs/guides" target="_self">Guides</a></li><li class="siteNavGroupActive"><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="/api/" target="_self">APIs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Organising your game</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Indigo</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/development-status">Indigo&#x27;s Development Status</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/quickstart/setup-and-configuration">Setup &amp; Configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/hello-indigo">Hello, Indigo!</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/examples">Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/project-templates">Mill &amp; SBT Game Templates</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Organising your game</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/organisation/boot-and-start-up">Boot &amp; Start Up</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/game-entry-points">Game Entry Points</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/organisation/scene-management">Scenes &amp; Scene Management</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/subsystems">SubSystems</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">The game loop</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gameloop/events">Events</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/frame-context">Frame context</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/outcome">Outcome Type</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Presentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/presentation/animation">Animation</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/audio">Audio</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/boundaries">Boundaries</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/cameras">Cameras</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/clones-and-mutants">Clones &amp; Mutants</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/depth">Depth</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/layers">Layers</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/materials">Materials</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/primitives">Primitives &amp; Building Blocks</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/scene-update-fragment">SceneUpdateFragment</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/text-and-fonts">Text &amp; Fonts</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">UI Components</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/uicomponents/ui-components">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/button">Buttons</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/hit-area">Hit Area</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/input-field">Input Field</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/radio-button">Radio Button</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shaders</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/shaders/shader-overview">Shaders Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/constants">Shader Constants, Variables, and Outputs</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/blending">Blending</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/premultiplied-alpha">Premultiplied Alpha</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Working with Time</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/time/signals">Signals &amp; Signal Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/time/time-varying-values">Time Varying Values</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Platform &amp; Publishing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/platform/assets">Assets &amp; Asset Loading</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/cross-platform-publishing">Cross Platform Publishing</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/importers">File Format Importers</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/input-handling">User Input Handling</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/loading-and-saving-data">Loading &amp; Saving Data</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/networking">Networking</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other information</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/information/alternatives">Alternatives to Indigo</a></li><li class="navListItem"><a class="navItem" href="/docs/information/glossary">Glossary</a></li><li class="navListItem"><a class="navItem" href="/docs/information/key-concepts">Key Concepts</a></li><li class="navListItem"><a class="navItem" href="/docs/information/model-viewmodel-view">Model, ViewModel, &amp; View</a></li><li class="navListItem"><a class="navItem" href="/docs/information/antipatterns">Anti-Patterns</a></li><li class="navListItem"><a class="navItem" href="/docs/information/motivation-and-constraints">Motivation &amp; Constraints</a></li><li class="navListItem"><a class="navItem" href="/docs/information/performance">Performance</a></li><li class="navListItem"><a class="navItem" href="/docs/information/prior-art">Prior Art</a></li><li class="navListItem"><a class="navItem" href="/docs/information/rendering-technology">Rendering Technology</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Scenes &amp; Scene Management</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="what-are-scenes"></a><a href="#what-are-scenes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are Scenes?</h2>
<p>As soon as you decide to build a game of any complexity, you immediately hit the problem of how to organize your code so that everything isn't lumped together. What you'd really like, hopefully, is a nice way to think about each part of your game in logical groups of state and functions i.e. All the things to do with your menu screen in one place, separated from your game over screen.</p>
<p>Most game engines have some sort of concept for these groupings, they're often called scenes, and Indigo is no exception.</p>
<h2><a class="anchor" aria-hidden="true" id="working-example-snake"></a><a href="#working-example-snake" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Working example: &quot;Snake!&quot;</h2>
<p>If you'd like to dive right in, the Snake implementation uses scenes to manage it's screens. To help you find your way around, here are a few points of interest:</p>
<ul>
<li><p>Initial declaration of the <a href="https://github.com/PurpleKingdomGames/indigo/blob/master/demos/snake/snake/src/snake/SnakeGame.scala#L19">list of scenes</a>.</p></li>
<li><p>The &quot;Start&quot; <a href="https://github.com/PurpleKingdomGames/indigo/blob/master/demos/snake/snake/src/snake/scenes/StartScene.scala">scene</a>, which is one of the simpler scenes in the game.</p></li>
<li><p>The point where the &quot;Start&quot; scene decides to <a href="https://github.com/PurpleKingdomGames/indigo/blob/master/demos/snake/snake/src/snake/scenes/StartScene.scala#L40">jump</a> to the &quot;Controls&quot; scene (where the player chooses a keyboard layout) after the space bar has been pressed.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="a-quick-look-under-the-hood"></a><a href="#a-quick-look-under-the-hood" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A quick look under the hood</h2>
<p>Scenes give the appearance of building a separate game per scene, with only a nod to the underlying mechanics.</p>
<p>The way it works, is that all scene data for every scene is held in the game's model and you provide a way to take it out and put it back again (known as a lens). Then the normal game update and presentation functions are delegated to the currently running scene, and scene navigation is controlled by events. That's it.</p>
<blockquote>
<p>In fact, you could build you're own scene system right on top of one of Indigo's other entry points if you were so inclined.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="building-a-game-with-scenes"></a><a href="#building-a-game-with-scenes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building a game with Scenes</h2>
<p>To use scenes, you need to use the <code>IndigoGame</code> entry point (extend an object in the usual way and fill in the blanks), which builds on <code>IndigoDemo</code> (which builds on <code>IndigoSandbox</code>) and adds the additional mechanics for using scenes.</p>
<p>The <code>IndigoGame</code> entry point looks almost the same as <code>IndigoDemo</code>, but adds these functions:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> indigo.*
<span class="hljs-keyword">import</span> indigo.scenes.*

<span class="hljs-comment">// Just examples</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootData</span>(<span class="hljs-params">debugModeOn: <span class="hljs-type">Boolean</span></span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartUpData</span>(<span class="hljs-params">viewport: <span class="hljs-type">Size</span></span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span>(<span class="hljs-params">inventory: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]</span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>(<span class="hljs-params">items: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]</span>)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scenes</span></span>(bootData: <span class="hljs-type">BootData</span>): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">Scene</span>[<span class="hljs-type">StartUpData</span>, <span class="hljs-type">Model</span>, <span class="hljs-type">ViewModel</span>]] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialScene</span></span>(bootData: <span class="hljs-type">BootData</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">SceneName</span>] = ???
</code></pre>
<p>These mean that you...</p>
<ol>
<li>That you <em>must</em> provide an <em>ordered</em> <code>NonEmptyList</code> (see below) of <code>Scenes</code>.</li>
<li>That you <em>can</em> provide the name of the first scene Indigo should use, otherwise the scene at the head of the list will be used.</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="building-a-scene"></a><a href="#building-a-scene" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building a Scene</h2>
<p>A scene is built by creating an object (or class) that extends <code>Scene[StartupData, GameModel, ViewModel]</code>. Here's the trait:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Scene</span>[<span class="hljs-type">StartUpData</span>, <span class="hljs-type">GameModel</span>, <span class="hljs-type">ViewModel</span>] <span class="hljs-title">derives</span> <span class="hljs-title">CanEqual</span> </span>{
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SceneModel</span></span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SceneViewModel</span></span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span></span>: <span class="hljs-type">SceneName</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modelLens</span></span>: <span class="hljs-type">Lens</span>[<span class="hljs-type">GameModel</span>, <span class="hljs-type">SceneModel</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">viewModelLens</span></span>: <span class="hljs-type">Lens</span>[<span class="hljs-type">ViewModel</span>, <span class="hljs-type">SceneViewModel</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eventFilters</span></span>: <span class="hljs-type">EventFilters</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subSystems</span></span>: <span class="hljs-type">Set</span>[<span class="hljs-type">SubSystem</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateModel</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">StartUpData</span>], model: <span class="hljs-type">SceneModel</span>): <span class="hljs-type">GlobalEvent</span> =&gt; <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneModel</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateViewModel</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">StartUpData</span>], model: <span class="hljs-type">SceneModel</span>, viewModel: <span class="hljs-type">SceneViewModel</span>): <span class="hljs-type">GlobalEvent</span> =&gt; <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneViewModel</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">present</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">StartUpData</span>], model: <span class="hljs-type">SceneModel</span>, viewModel: <span class="hljs-type">SceneViewModel</span>): <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneUpdateFragment</span>]
}
</code></pre>
<div id="mdoc-html-run1" data-mdoc-js></div>
<p>As you can hopefully see, mostly this is very much like a normal game, but for a few exceptions:</p>
<ol>
<li>No initialization, animations or fonts, that all happens in the main game (shown in the previous section).</li>
<li>Scenes have a name, which is important for navigation.</li>
<li>Scenes have their own models and view models, more on that later.</li>
<li>The game can have global sub systems, and scenes can also have their own subsystems too.</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="funny-types"></a><a href="#funny-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Funny types</h2>
<p>There's a couple of funny types in the code snippets above, namely <code>NonEmptyList</code> and <code>Lens</code>. The main thing to stress (if you're familiar with them already) is that they are minimal implementations within Indigo itself, and not the fully featured versions you might find in specialist libraries.</p>
<p>This choice - right or wrong - was made because most of Indigo is vanilla Scala* and requires nothing out of the ordinary to work beyond Scala.js, but just occasionally we can do much better with a cleverer type.</p>
<p>The two used above are <code>NonEmptyList</code> and <code>Lens</code>. The latter is discussed in the next section. A <code>NonEmptyList</code> is a <code>List</code> that cannot be empty, i.e. it will always have at least one element, and so the normally unsafe (i.e. throws an exception if the list is empty) <code>.head</code> method becomes a safe operation. You can think of the encoding as being like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonEmptyList</span>[<span class="hljs-type">A</span>](<span class="hljs-params">head: <span class="hljs-type">A</span>, tail: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toList</span></span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = head :: tail
}
</code></pre>
<div id="mdoc-html-run2" data-mdoc-js></div>
<blockquote>
<p>*There is absolutely nothing stopping you from using all your favorite libraries, such as Cats or Monocle.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="navigating-between-scenes"></a><a href="#navigating-between-scenes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Navigating between scenes</h2>
<p>The non-empty list of scenes in the original declaration is static, and cannot be added to later in the game. It is also ordered.</p>
<p>Here's the one from Snake:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scenes</span></span>(bootData: <span class="hljs-type">GameViewport</span>): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">Scene</span>[<span class="hljs-type">SnakeStartupData</span>, <span class="hljs-type">SnakeGameModel</span>, <span class="hljs-type">SnakeViewModel</span>]] =
    <span class="hljs-type">NonEmptyList</span>(<span class="hljs-type">StartScene</span>, <span class="hljs-type">ControlsScene</span>, <span class="hljs-type">GameScene</span>, <span class="hljs-type">GameOverScene</span>)
</code></pre>
<p>Snake also declares it's initial scene like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialScene</span></span>(bootData: <span class="hljs-type">GameViewport</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">SceneName</span>] = <span class="hljs-type">Option</span>(<span class="hljs-type">StartScene</span>.name)
</code></pre>
<p>But this isn't actually necessary since <code>StartScene</code> is at the head of the list.</p>
<p>To move between scenes you use events, defined simply as:</p>
<pre><code class="hljs css language-scala">enum <span class="hljs-type">SceneEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">GlobalEvent</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-type">Next</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">SceneEvent</span>
  <span class="hljs-keyword">case</span> <span class="hljs-type">Previous</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">SceneEvent</span>
  <span class="hljs-keyword">case</span> <span class="hljs-type">JumpTo</span>(name: <span class="hljs-type">SceneName</span>) <span class="hljs-keyword">extends</span> <span class="hljs-type">SceneEvent</span>
  <span class="hljs-keyword">case</span> <span class="hljs-type">SceneChange</span>(from: <span class="hljs-type">SceneName</span>, to: <span class="hljs-type">SceneName</span>, at: <span class="hljs-type">Seconds</span>) <span class="hljs-keyword">extends</span> <span class="hljs-type">SceneEvent</span>
</code></pre>
<div id="mdoc-html-run3" data-mdoc-js></div>
<p><code>Next</code> and <code>Previous</code> proceed forwards and backwards respectively through the list of scenes until they run out. They do not loop back on themselves.</p>
<p><code>JumpTo</code> moves to whichever scene you specify with the <code>SceneName</code>. This turns out of be very convenient since scenes are normally objects, and you can just call something like <code>JumpTo(GameOverScene.name)</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="state-handling-with-lenses"></a><a href="#state-handling-with-lenses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State handling with Lenses</h2>
<p>The final thing to know about with <code>Scene</code>s, is how they manage state.</p>
<p>Essentially the model of the game contains the state for all scenes. This applies to both model and view model, but we'll just talk about the model from now on. Consider a game with the following model:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuModel</span>(<span class="hljs-params">menuItems: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]</span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LevelModel</span>(<span class="hljs-params">health: <span class="hljs-type">Int</span>, inventory: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]</span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DungeonGameModel</span>(<span class="hljs-params">menuScene: <span class="hljs-type">MenuModel</span>, level: <span class="hljs-type">LevelModel</span></span>)</span>

<span class="hljs-keyword">val</span> level: <span class="hljs-type">LevelModel</span> = <span class="hljs-type">LevelModel</span>(<span class="hljs-number">10</span>, <span class="hljs-type">Map</span>(<span class="hljs-string">"health potions"</span> -&gt; <span class="hljs-number">3</span>))
<span class="hljs-keyword">val</span> model: <span class="hljs-type">DungeonGameModel</span> = <span class="hljs-type">DungeonGameModel</span>(<span class="hljs-type">MenuModel</span>(<span class="hljs-type">List</span>(<span class="hljs-string">"Press space to start!"</span>)), level)
</code></pre>
<p>Here is a simple lens that will extract the <code>LevelModel</code> from the <code>DungeonGameModel</code> and put it back again:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Lens</span>[<span class="hljs-type">DungeonGameModel</span>, <span class="hljs-type">LevelModel</span>](
  getter = (model: <span class="hljs-type">DungeonGameModel</span>) =&gt; model.level,
  setter = (model: <span class="hljs-type">DungeonGameModel</span>, nextLevel: <span class="hljs-type">LevelModel</span>) =&gt; model.copy(level = nextLevel)
)
</code></pre>
<div id="mdoc-html-run5" data-mdoc-js></div>
<p>Let's declare a scene that is using this fictional model:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">LevelScene</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scene</span>[<span class="hljs-type">Unit</span>, <span class="hljs-type">DungeonGameModel</span>, <span class="hljs-type">Unit</span>]</span>:
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SceneModel</span> </span>= <span class="hljs-type">LevelModel</span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SceneViewModel</span> </span>= <span class="hljs-type">Unit</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eventFilters</span></span>: <span class="hljs-type">EventFilters</span> = <span class="hljs-type">EventFilters</span>.<span class="hljs-type">Permissive</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modelLens</span></span>: <span class="hljs-type">Lens</span>[<span class="hljs-type">DungeonGameModel</span>, <span class="hljs-type">LevelModel</span>] = <span class="hljs-type">Lens</span>(_.level, (m, lvl) =&gt; m.copy(level = lvl))
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">viewModelLens</span></span>: <span class="hljs-type">Lens</span>[<span class="hljs-type">Unit</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-type">Lens</span>.unit
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span></span>: <span class="hljs-type">SceneName</span> = <span class="hljs-type">SceneName</span>(<span class="hljs-string">"level"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subSystems</span></span>: <span class="hljs-type">Set</span>[<span class="hljs-type">SubSystem</span>] = <span class="hljs-type">Set</span>()

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateModel</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">Unit</span>], model: <span class="hljs-type">LevelModel</span>): <span class="hljs-type">GlobalEvent</span> =&gt; <span class="hljs-type">Outcome</span>[<span class="hljs-type">LevelModel</span>] =
    _ =&gt; <span class="hljs-type">Outcome</span>(model.copy(health = model.health + <span class="hljs-number">1</span>)) <span class="hljs-comment">// On any event, increase health!</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateViewModel</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">Unit</span>], model: <span class="hljs-type">LevelModel</span>, viewModel: <span class="hljs-type">Unit</span>): <span class="hljs-type">GlobalEvent</span> =&gt; <span class="hljs-type">Outcome</span>[<span class="hljs-type">Unit</span>] =
    _ =&gt; <span class="hljs-type">Outcome</span>(viewModel)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">present</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">Unit</span>], model: <span class="hljs-type">LevelModel</span>, viewModel: <span class="hljs-type">Unit</span>): <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneUpdateFragment</span>] =
    <span class="hljs-type">Outcome</span>(<span class="hljs-type">SceneUpdateFragment</span>.empty)
</code></pre>
<div id="mdoc-html-run6" data-mdoc-js></div>
<p>Notice that the <code>modelLens</code> uses a shorter version of the same lens we wrote earlier, but it's the same thing.</p>
<p>Now when we run the game, the scene manager uses the lens to extract <code>LevelModel</code> from the <code>DungeonGameModel</code>, <code>updateModel</code> function updates the <code>LevelModel</code>, and then the scene manager uses the lens again to replace the old version with the new one.</p>
<h3><a class="anchor" aria-hidden="true" id="lenses"></a><a href="#lenses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lenses</h3>
<p>To formalize this sort of relationship, Indigo has a just-about-good-enough <code>Lens</code> implementation (there are no prisms or anything fancy). Lenses are a really interesting subject and if you'd like to know more you could take a look at something like <a href="https://github.com/optics-dev/Monocle">Monocle</a>.</p>
<p>An Indigo lens implements a <code>get</code> and a <code>set</code> function, like so:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](from: <span class="hljs-type">A</span>): <span class="hljs-type">B</span> = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](into: <span class="hljs-type">A</span>, value: <span class="hljs-type">B</span>): <span class="hljs-type">A</span> = ???
</code></pre>
<div id="mdoc-html-run7" data-mdoc-js></div>
<ul>
<li><code>get</code> looks at, in our case, <code>DungeonGameModel</code> and extracts / returns <code>LevelModel</code>.</li>
<li><code>set</code> puts a <code>LevelModel</code> into a <code>DungeonGameModel</code> and returns the new <code>DungeonGameModel</code> instance.</li>
</ul>
<p>Lets try it out! Lets start with the simple <code>copy</code> example from earlier:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> modelLens =
  <span class="hljs-type">Lens</span>[<span class="hljs-type">DungeonGameModel</span>, <span class="hljs-type">LevelModel</span>](
    getter = (model: <span class="hljs-type">DungeonGameModel</span>) =&gt; model.level,
    setter = (model: <span class="hljs-type">DungeonGameModel</span>, nextLevel: <span class="hljs-type">LevelModel</span>) =&gt; model.copy(level = nextLevel)
  )

modelLens.get(model) <span class="hljs-comment">// LevelModel</span>
modelLens.set(model, level) <span class="hljs-comment">// DungeonGameModel</span>
</code></pre>
<div id="mdoc-html-run8" data-mdoc-js></div>
<p>You can also do things like construct temporary models by aggregating several parts of the main model into a one-shot case class, that you than de-construct and discard at the end of the frame when putting the values back.</p>
<h3><a class="anchor" aria-hidden="true" id="lens-composition"></a><a href="#lens-composition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lens composition</h3>
<p>We can also posed the question of how you update things inside other things, for this we have to compose lenses together using the <code>andThen</code> operator, for example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sword</span>(<span class="hljs-params">shininess: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weapons</span>(<span class="hljs-params">sword: <span class="hljs-type">Sword</span></span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inventory</span>(<span class="hljs-params">weapons: <span class="hljs-type">Weapons</span></span>)</span>

<span class="hljs-keyword">val</span> inventoryLens: <span class="hljs-type">Lens</span>[<span class="hljs-type">Inventory</span>, <span class="hljs-type">Weapons</span>] =
  <span class="hljs-type">Lens</span>(_.weapons, (i, w) =&gt; i.copy(weapons = w))

<span class="hljs-keyword">val</span> weaponsLens: <span class="hljs-type">Lens</span>[<span class="hljs-type">Weapons</span>, <span class="hljs-type">Sword</span>] =
  <span class="hljs-type">Lens</span>(_.sword, (w, s) =&gt; w.copy(sword = s))

<span class="hljs-keyword">val</span> inventory     = <span class="hljs-type">Inventory</span>(<span class="hljs-type">Weapons</span>(<span class="hljs-type">Sword</span>(<span class="hljs-number">1</span>)))
<span class="hljs-keyword">val</span> betterSword   = <span class="hljs-type">Sword</span>(<span class="hljs-number">2</span>)

<span class="hljs-keyword">val</span> mySwordLens = 
  inventoryLens andThen weaponsLens <span class="hljs-comment">// Composing lenses!</span>

mySwordLens.get(inventory) <span class="hljs-comment">// a sword</span>
mySwordLens.set(inventory, betterSword) <span class="hljs-comment">// an inventory with a better sword in it</span>

<span class="hljs-keyword">val</span> polishTheSword: <span class="hljs-type">Sword</span> =&gt; <span class="hljs-type">Sword</span> = s =&gt; s.copy(shininess = s.shininess + <span class="hljs-number">1</span>)

mySwordLens.modify(inventory, polishTheSword)
<span class="hljs-comment">// modify is the just the composition of get, set, and a function f.</span>
</code></pre>
<div id="mdoc-html-run9" data-mdoc-js></div>
<h3><a class="anchor" aria-hidden="true" id="limitations"></a><a href="#limitations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Limitations</h3>
<p>As with all things in Indigo, the <code>Lens</code> implementation is the bare minimum needed - if you assume most models are just nested objects - and does not currently support things like prisms.</p>
<p>No doubt extra functionality will be added as soon as the need arises, but in the meantime, note that Indigo's lens definition says nothing about how it's implemented. If you had a complicated case, you could look at building your lenses using a Scala.js compatible lens library, and just use the Indigo Lens as an interface to the engine.</p>
<h2><a class="anchor" aria-hidden="true" id="global-operations"></a><a href="#global-operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Global operations</h2>
<p>The <code>IndigoGame</code> entry point also provides the standard update and present functions that run at a global level. This wasn't in the original design because it is quite confusing! Unfortunately it's also very useful and the benefits out-weigh the complexity drawbacks.</p>
<p><strong>The Good!</strong></p>
<p>Example: Your model is comprised of the data needed for each level as a separate field in a case class, and you have a global inventory. You'd like to be able to update both.</p>
<p>One way to do that is with a slightly complicated lens arrangement that knows how to extract both into a temporary object that only exists for this frame, and then de-construct that object to set the new values back into the main model. That works, but it get increasingly complicated the more elements you need to draw together, and eventually the temptation is just to use the whole model, which defeats the point of having the lenses.</p>
<p>The other way, as long as the update isn't time critical, is to emit an event! If you emit an event then the event can be caught in the next frame at the global level and the inventory can be updated. Nice and clean. As mentioned this works well for updates that aren't time critical since the effect won't be visible until the frame after next.</p>
<p><strong>The not so good..</strong></p>
<p>You'd like to render a global UI at all times - great - this can be done with our global present function.</p>
<p><em>...but how will that be merged with the scene's own present function?</em></p>
<p>Well, the global view is always processed first. The idea is that you should use layers with layer keys to control output destinations since the original position of layers with keys is preserved when another layer with the same key is added to the scene.</p>
<h2><a class="anchor" aria-hidden="true" id="tips-for-working-with-scenes"></a><a href="#tips-for-working-with-scenes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips for working with Scenes</h2>
<h3><a class="anchor" aria-hidden="true" id="passing-events-between-scenes"></a><a href="#passing-events-between-scenes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Passing events between scenes</h3>
<p>When one scene is running none of the others are, but sometimes it's useful to be able to pass a message to the scene you're about to switch to.</p>
<p>This turns out to be very easy in Indigo. Since events are ordered and strictly evaluated, all you need to do is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageForNextScene</span>(<span class="hljs-params">message: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">GlobalEvent</span></span>

<span class="hljs-type">Outcome</span>(model) <span class="hljs-comment">// here, the result of a model update, but could be any Outcome</span>
  .addGlobalEvents(
    <span class="hljs-type">SceneEvent</span>.<span class="hljs-type">JumpTo</span>(<span class="hljs-type">SceneName</span>(<span class="hljs-string">"next!"</span>)),
    <span class="hljs-type">MessageForNextScene</span>(<span class="hljs-string">"Hello next scene!"</span>)
  )
</code></pre>
<div id="mdoc-html-run10" data-mdoc-js></div>
<p>The first event will re-route all functions to the new scene, and the next event will therefore be received immediately by that scene.</p>
<script type="text/javascript" src="scene-management.md.js" defer></script>
<script type="text/javascript" src="mdoc.js" defer></script>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/organisation/game-entry-points"><span class="arrow-prev">← </span><span>Game Entry Points</span></a><a class="docs-next button" href="/docs/organisation/subsystems"><span class="function-name-prevnext">SubSystems</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-are-scenes">What are Scenes?</a></li><li><a href="#working-example-snake">Working example: &quot;Snake!&quot;</a></li><li><a href="#a-quick-look-under-the-hood">A quick look under the hood</a></li><li><a href="#building-a-game-with-scenes">Building a game with Scenes</a></li><li><a href="#building-a-scene">Building a Scene</a></li><li><a href="#funny-types">Funny types</a></li><li><a href="#navigating-between-scenes">Navigating between scenes</a></li><li><a href="#state-handling-with-lenses">State handling with Lenses</a><ul class="toc-headings"><li><a href="#lenses">Lenses</a></li><li><a href="#lens-composition">Lens composition</a></li><li><a href="#limitations">Limitations</a></li></ul></li><li><a href="#global-operations">Global operations</a></li><li><a href="#tips-for-working-with-scenes">Tips for working with Scenes</a><ul class="toc-headings"><li><a href="#passing-events-between-scenes">Passing events between scenes</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a><a href="/docs/en/quickstart/project-templates">Project templates</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://github.com/PurpleKingdomGames/indigo/discussions">GitHub Discussons</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section></footer></div></body></html>