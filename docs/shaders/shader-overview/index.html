<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Shaders Overview · Indigo</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## What is a shader?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Shaders Overview · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="## What is a shader?"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="Indigo Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="Indigo Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/docs/guides" target="_self">Guides</a></li><li class="siteNavGroupActive"><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="/api/" target="_self">APIs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Shaders</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Indigo</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/development-status">Indigo&#x27;s Development Status</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/quickstart/setup-and-configuration">Setup &amp; Configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/hello-indigo">Hello, Indigo!</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/examples">Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/quickstart/project-templates">Mill &amp; SBT Game Templates</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Organising your game</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/organisation/boot-and-start-up">Boot &amp; Start Up</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/game-entry-points">Game Entry Points</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/scene-management">Scenes &amp; Scene Management</a></li><li class="navListItem"><a class="navItem" href="/docs/organisation/subsystems">SubSystems</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">The game loop</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gameloop/events">Events</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/frame-context">Frame context</a></li><li class="navListItem"><a class="navItem" href="/docs/gameloop/outcome">Outcome Type</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Presentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/presentation/animation">Animation</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/audio">Audio</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/boundaries">Boundaries</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/cameras">Cameras</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/clones-and-mutants">Clones &amp; Mutants</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/depth">Depth</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/layers">Layers</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/materials">Materials</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/primitives">Primitives &amp; Building Blocks</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/scene-update-fragment">SceneUpdateFragment</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/presentation/text-and-fonts">Text &amp; Fonts</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">UI Components</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/uicomponents/ui-components">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/button">Buttons</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/hit-area">Hit Area</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/input-field">Input Field</a></li><li class="navListItem"><a class="navItem" href="/docs/uicomponents/radio-button">Radio Button</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shaders</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/shaders/shader-overview">Shaders Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/constants">Shader Constants, Variables, and Outputs</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/blending">Blending</a></li><li class="navListItem"><a class="navItem" href="/docs/shaders/premultiplied-alpha">Premultiplied Alpha</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Working with Time</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/time/signals">Signals &amp; Signal Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/time/time-varying-values">Time Varying Values</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Platform &amp; Publishing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/platform/assets">Assets &amp; Asset Loading</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/cross-platform-publishing">Cross Platform Publishing</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/importers">File Format Importers</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/input-handling">User Input Handling</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/loading-and-saving-data">Loading &amp; Saving Data</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/logging">Logging</a></li><li class="navListItem"><a class="navItem" href="/docs/platform/networking">Networking</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other information</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/information/alternatives">Alternatives to Indigo</a></li><li class="navListItem"><a class="navItem" href="/docs/information/glossary">Glossary</a></li><li class="navListItem"><a class="navItem" href="/docs/information/key-concepts">Key Concepts</a></li><li class="navListItem"><a class="navItem" href="/docs/information/model-viewmodel-view">Model, ViewModel, &amp; View</a></li><li class="navListItem"><a class="navItem" href="/docs/information/antipatterns">Anti-Patterns</a></li><li class="navListItem"><a class="navItem" href="/docs/information/motivation-and-constraints">Motivation &amp; Constraints</a></li><li class="navListItem"><a class="navItem" href="/docs/information/performance">Performance</a></li><li class="navListItem"><a class="navItem" href="/docs/information/prior-art">Prior Art</a></li><li class="navListItem"><a class="navItem" href="/docs/information/rendering-technology">Rendering Technology</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Shaders Overview</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="what-is-a-shader"></a><a href="#what-is-a-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a shader?</h2>
<p>A shader program is a compiled computer program executed on your graphics card that instructs the GPU &quot;where&quot; on the screen to draw to, and &quot;what&quot; to draw when it gets there. In the case of Indigo which uses WebGL 2.0, a shader is made up of a pair of programs, called the vertex (where) and fragment (what) programs.</p>
<blockquote>
<p>The terms &quot;shader&quot;, &quot;program&quot;, and &quot;shader program&quot; are used somewhat inter-changeably here.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="aim-of-the-shader-docs"></a><a href="#aim-of-the-shader-docs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aim of the shader docs</h2>
<p>Shaders are a big subject and beyond the scope of this documentation site, the aim here is just to give you enough information to get you started with shaders in Indigo (which have a particular flavour), not to teach you how to write shaders in general.</p>
<h2><a class="anchor" aria-hidden="true" id="how-to-get-started-with-shaders"></a><a href="#how-to-get-started-with-shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to get started with Shaders</h2>
<p>There is a brief introduction to using shaders in your project as part of the <a href="/docs/guides/howto-custom-entity">&quot;how to create a custom entity&quot;</a> guide that we recommend you read first, which also has an accompanying <a href="https://github.com/PurpleKingdomGames/indigo-examples/tree/master/howto/custom-entity">example repo</a>.</p>
<p>There is a follow on tutorial to the one above than explains <a href="/docs/guides/howto-fire-shader">how to make a fire shader</a> that you may also find useful.</p>
<h2><a class="anchor" aria-hidden="true" id="entity-vs-blend-shaders"></a><a href="#entity-vs-blend-shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Entity vs Blend Shaders</h2>
<p>Indigo has two distinct flavours of shader.</p>
<ol>
<li><a href="entity-shaders.md">Entity shaders</a> are used to draw individual items / entities on the screen.</li>
<li>Blend shaders are used in the <a href="/docs/shaders/blending">blending process</a> to tell Indigo how to merge layers together.</li>
</ol>
<p>They both work in a similar way, but there are differences.</p>
<h3><a class="anchor" aria-hidden="true" id="functions-available-for-override"></a><a href="#functions-available-for-override" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions available for override</h3>
<p>A large part of what you're doing when writing shaders is providing implementations for shader functions that are called at different stages of the shading process. Both types of shader support a <code>vertex</code> and <code>fragment</code> stage, but entity shaders also have <code>prepare</code>, <code>light</code>, and <code>composite</code> which are used for lighting.</p>
<p>The default implementations are simply blank function calls, as follows:</p>
<p><strong>Entity shader functions</strong></p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> vertex(){}
<span class="hljs-type">void</span> fragment(){}
<span class="hljs-type">void</span> prepare(){}
<span class="hljs-type">void</span> light(){}
<span class="hljs-type">void</span> composite(){}
</code></pre>
<p><strong>Blend shader functions</strong></p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> vertex(){}
<span class="hljs-type">void</span> fragment(){}
</code></pre>
<p><strong>Function uses</strong></p>
<table>
<thead>
<tr><th>Name</th><th>Sequential order</th><th>description</th></tr>
</thead>
<tbody>
<tr><td><code>vertex</code></td><td>1</td><td>Used to modify the space on the screen the entity occupies, and to pass data to the fragment shader.</td></tr>
<tr><td><code>fragment</code></td><td>2</td><td>Tells Indigo what color each pixel needs to be.</td></tr>
<tr><td><code>prepare</code></td><td>3</td><td>Called before <code>light</code>, prepare gives you an opportunity to set up any data or functions needed for the lighting process.</td></tr>
<tr><td><code>light</code></td><td>4..4n</td><td>Called before <code>composite</code>, <code>light</code> is called once per light in the scene, and is used to build up per pixel lighting data separate from the colour data that results from <code>fragment</code>.</td></tr>
<tr><td><code>composite</code></td><td>5</td><td>Called last, <code>composite</code> is used to override how lighting information is combined with unlit pixel color data.</td></tr>
</tbody>
</table>
<p>To override a function you simply need to declare it. In an <code>Source</code> shader type, this could be done as follows:</p>
<pre><code class="hljs css language-scala">import indigo.*

val shader: EntityShader =
  EntityShader
    .Source(ShaderId("my-colored-shader"))
    .withFragmentProgram(
      """
      |void fragment() {
      |  COLOR = vec4(0.0, 1.0, 0.0, 1.0);
      |}
      |""".stripMargin
      )
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="external-source-files"></a><a href="#external-source-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>External source files</h4>
<p>External files are more convenient for shader editing, allowing you to use tools like linters, and Indigo has a particular way of structuring them. The idea was to allow you as far as possible to utilise all existing GLSL editing tools, so the process below is designed not to interfere with them.</p>
<p>In an external shader file, we need to tell Indigo which parts of the file to use where, like this:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-comment">//&lt;indigo-fragment&gt;</span>
<span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
<span class="hljs-comment">//&lt;/indigo-fragment&gt;</span>
</code></pre>
<p>Indigo uses tags like the one above to do this, the tags are simply as follows (note that the <code>//</code> comments are significant so that GLSL tools ignore them):</p>
<pre><code class="hljs css language-glsl">//&lt;indigo-"function to override"&gt;
void "function to override"() {
  ..
}
//&lt;/indigo-"function to override"&gt;
</code></pre>
<p>Any code declared inside the &quot;tags&quot; will be inserted into the final shader, and you are not limited to declaring only the required override function, you could declare other functions and variables as needed.</p>
<p>Another useful trick is declaring variables outside the tags. If for example, you'd like to use Indigo's in-built <code>UV</code> variable, you can do this:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">vec2</span> UV;

<span class="hljs-comment">//&lt;indigo-fragment&gt;</span>
<span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(UV, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
<span class="hljs-comment">//&lt;/indigo-fragment&gt;</span>
</code></pre>
<p>This allows the GLSL linting tools to pass since the variable is declared before it is used, but Indigo will ignore it and use the real one instead.</p>
<h3><a class="anchor" aria-hidden="true" id="constants-and-variables"></a><a href="#constants-and-variables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constants and variables</h3>
<p>The different shader types also have some shared and some specific constants available to them, for example entity shaders read texture colours from the <code>CHANNEL_0</code>, <code>CHANNEL_1</code>, <code>CHANNEL_2</code> and <code>CHANNEL_3</code> variables, but blend shaders use <code>SRC</code> and <code>DST</code> instead.</p>
<p>A complete list is available on the <a href="/docs/shaders/constants">&quot;Shader Constants, Variables, and Outputs&quot;</a> page.</p>
<h2><a class="anchor" aria-hidden="true" id="loading-external-shader-files"></a><a href="#loading-external-shader-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading external shader files</h2>
<p>Getting an external shader into Indigo is no different from loading any other text asset:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assets</span></span>: <span class="hljs-type">Set</span>[<span class="hljs-type">AssetType</span>] =
  <span class="hljs-type">Set</span>(
    <span class="hljs-type">AssetType</span>.<span class="hljs-type">Text</span>(<span class="hljs-type">AssetName</span>(<span class="hljs-string">"my vertex shader"</span>), <span class="hljs-type">AssetPath</span>(<span class="hljs-string">"assets/shader.vert"</span>)),
    <span class="hljs-type">AssetType</span>.<span class="hljs-type">Text</span>(<span class="hljs-type">AssetName</span>(<span class="hljs-string">"my fragment shader"</span>), <span class="hljs-type">AssetPath</span>(<span class="hljs-string">"assets/shader.frag"</span>))
  )
</code></pre>
<div id="mdoc-html-run1" data-mdoc-js></div>
<blockquote>
<p>Note, best practice is to do what is shown in this example and have two shader files with the same name, one with a <code>.vert</code> and the other with a <code>.frag</code> extension. These are standard shader file names that your GLSL editor of choice will understand. Technically they could all be in the same file, but if you need to pass data from your vertex to your fragment shader (using varyings) then you'll run into problems with conflicting variable names, e.g. you'd have to declare <code>out vec4 mydata;</code> and <code>in vec4 mydata;</code> in the same file, which a linter won't like.</p>
</blockquote>
<p>Here we're loading two shader files with potentially a complete set of function overrides, but please note that you only need to supply what you need. If you only need a fragment shader that overrides <code>void fragment(){}</code>, you can just supply that and Indigo will use defaults for the others.</p>
<p>Next we need to build our shader:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CustomShader</span></span>:
  <span class="hljs-keyword">val</span> vertAsset: <span class="hljs-type">AssetName</span> = <span class="hljs-type">AssetName</span>(<span class="hljs-string">"my vertex shader"</span>)
  <span class="hljs-keyword">val</span> fragAsset: <span class="hljs-type">AssetName</span> = <span class="hljs-type">AssetName</span>(<span class="hljs-string">"my fragment shader"</span>)

  <span class="hljs-keyword">val</span> shader: <span class="hljs-type">EntityShader</span>.<span class="hljs-type">External</span> =
    <span class="hljs-type">EntityShader</span>
      .<span class="hljs-type">External</span>(<span class="hljs-type">ShaderId</span>(<span class="hljs-string">"my shader"</span>))
      .withVertexProgram(vertAsset)
      .withFragmentProgram(fragAsset)
      .withLightProgram(fragAsset)
</code></pre>
<div id="mdoc-html-run2" data-mdoc-js></div>
<p>Finally we need to tell Indigo about these shaders, or we won't be able to use them:</p>
<pre><code class="hljs css language-scala">    <span class="hljs-type">Outcome</span>(
      <span class="hljs-type">BootResult</span>.noData(<span class="hljs-type">GameConfig</span>.<span class="hljs-keyword">default</span>)
        .withShaders(<span class="hljs-type">CustomShader</span>.shader)
    )
</code></pre>
<blockquote>
<p>Note that shaders must be fully declared during game boot up, you cannot add more later.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="using-shaders-in-your-scene"></a><a href="#using-shaders-in-your-scene" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using shaders in your scene</h2>
<p>Custom shaders are generally expected to be used in conjunction with custom entities, please see the <a href="/docs/guides/howto-custom-entity">guide</a> for examples.</p>
<p>You can also use custom shaders to override the behavior of built-in materials. Technically this is as easy as replacing the <code>shaderId: Option[ShaderId]</code> field on the material with the id of your own shader, but you will need to look into the source code to determine data that material provides to the shader.</p>
<h2><a class="anchor" aria-hidden="true" id="providing-data-to-your-shaders"></a><a href="#providing-data-to-your-shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing data to your shaders</h2>
<p>Shaders without any data can still be useful if you have a known effect, and not sending data is less costly than sending it! However, sometimes you need to tell your shader about what you need it to do, and for that we use <code>UniformBlock</code>s (know as UBO's technically, Uniform Buffer Objects).</p>
<p>In the <a href="/docs/guides/howto-custom-entity">guide</a>, we create a custom entity that fills it's self with a solid color:</p>
<pre><code class="hljs css language-scala">final case class MyColoredEntity(position: Point, depth: Depth) extends EntityNode[MyColoredEntity]:
  def size: Size        = Size(32, 32)
  def flip: Flip        = Flip.default
  def ref: Point        = Point.zero
  def rotation: Radians = Radians.zero
  def scale: Vector2    = Vector2.one

  def eventHandler: ((MyColoredEntity, GlobalEvent)) =&gt; Option[GlobalEvent] = _ =&gt; None
  def eventHandlerEnabled: Boolean = false

  def withDepth(newDepth: Depth): MyColoredEntity =
    this.copy(depth = newDepth)

  def toShaderData: ShaderData =
    ShaderData(MyColoredEntity.shader.id)

object MyColoredEntity:
  val shader: EntityShader =
    EntityShader
      .Source(ShaderId("my-colored-shader"))
      .withFragmentProgram(
        """
        |void fragment() {
        |  COLOR = vec4(0.0, 1.0, 0.0, 1.0);
        |}
        |""".stripMargin
      )
</code></pre>
<div id="mdoc-html-run3" data-mdoc-js></div>
<p>If we wanted to supply the colour, we need to modify our code as follows:</p>
<pre><code class="hljs css language-scala">import indigo.ShaderPrimitive.*

final case class MyColoredEntity(position: Point, depth: Depth, color: RGBA) extends EntityNode[MyColoredEntity]:
  def size: Size        = Size(32, 32)
  def flip: Flip        = Flip.default
  def ref: Point        = Point.zero
  def rotation: Radians = Radians.zero
  def scale: Vector2    = Vector2.one

  def eventHandler: ((MyColoredEntity, GlobalEvent)) =&gt; Option[GlobalEvent] = _ =&gt; None
  def eventHandlerEnabled: Boolean = false

  def withDepth(newDepth: Depth): MyColoredEntity =
    this.copy(depth = newDepth)

  def toShaderData: ShaderData =
    ShaderData(
      MyColoredEntity.shader.id,
      UniformBlock(
        "MyCustomData",
        Batch(Uniform("MY_COLOR") -&gt; vec4(color.r, color.g, color.b, color.a))
      )
    )

object MyColoredEntity:
  val shader: EntityShader =
    EntityShader
      .Source(ShaderId("my-colored-shader"))
      .withFragmentProgram(
        """
        |layout (std140) uniform MyCustomData {
        |  vec4 MY_COLOR;
        |};
        |
        |void fragment() {
        |  COLOR = MY_COLOR;
        |}
        |""".stripMargin
      )
</code></pre>
<div id="mdoc-html-run4" data-mdoc-js></div>
<p>The <code>toShaderData</code> function now includes a uniform block that declares (in this case) a single variable called &quot;MY_COLOR&quot; of type <code>vec4</code>.</p>
<blockquote>
<p>Aside, the variable names are not checked! It's the order that matters, but keep the names the same for your own sanity...</p>
</blockquote>
<p>We then declare a uniform block (a special kind of struct) in the shader code, and then we can use the variable in your fragment function.</p>
<p>Please note that variables sent over as uniform blocks are subject to data packing rules! See below!</p>
<h2><a class="anchor" aria-hidden="true" id="uniformblock--ubo-data-packing-rules"></a><a href="#uniformblock--ubo-data-packing-rules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>UniformBlock</code> / UBO Data Packing Rules</h2>
<p>Take heed! These rules have saved me many times and originally came from here: <a href="https://youtu.be/bdIZ2ZloXEA?t=113">https://youtu.be/bdIZ2ZloXEA?t=113</a></p>
<pre><code class="hljs"><span class="hljs-string">"UBO - Uniform Buffer Object"</span>

<span class="hljs-symbol">Uses</span> a <span class="hljs-keyword">struct </span>as a way to defined the <span class="hljs-meta">data</span> in the <span class="hljs-keyword">buffer.
</span><span class="hljs-keyword">Struct </span><span class="hljs-meta">data</span> <span class="hljs-keyword">based </span>on STD140 layout requires <span class="hljs-meta">data</span> to exist in <span class="hljs-number">16</span> <span class="hljs-keyword">byte </span>chunks.

<span class="hljs-symbol">Float</span>, Int <span class="hljs-keyword">and </span><span class="hljs-keyword">Bools </span>are treated as <span class="hljs-number">4</span> <span class="hljs-keyword">Bytes </span>of <span class="hljs-meta">Data</span>.

<span class="hljs-symbol">Arrays</span>, no matter the type, each element is <span class="hljs-number">16</span> <span class="hljs-keyword">Bytes.
</span>
<span class="hljs-symbol">vec2</span>, Contains <span class="hljs-number">2</span> floats so <span class="hljs-number">4</span>*<span class="hljs-number">2</span> <span class="hljs-keyword">bytes </span>of <span class="hljs-meta">data</span> (<span class="hljs-number">8</span> <span class="hljs-keyword">Bytes)
</span><span class="hljs-symbol">vec4</span>, Contains <span class="hljs-number">4</span> floats so <span class="hljs-number">4</span>*<span class="hljs-number">4</span> <span class="hljs-keyword">bytes </span>of <span class="hljs-meta">data</span> (<span class="hljs-number">16</span> <span class="hljs-keyword">Bytes)
</span><span class="hljs-symbol">vec3</span>, Must <span class="hljs-keyword">be </span>treated as <span class="hljs-number">16</span> <span class="hljs-keyword">bytes </span>of <span class="hljs-meta">data</span> (i.e. a vec4), last <span class="hljs-number">4</span> <span class="hljs-keyword">bytes </span>are <span class="hljs-keyword">buffer </span><span class="hljs-meta">space</span>

<span class="hljs-symbol">mat3</span>, Contains <span class="hljs-number">3</span> <span class="hljs-meta">sets</span> of Vec3 <span class="hljs-keyword">BUT </span>each vec3 is treated as vec4, <span class="hljs-number">3</span>*<span class="hljs-number">16</span> <span class="hljs-keyword">Bytes </span>of <span class="hljs-meta">data</span>
<span class="hljs-symbol">mat4</span>, Contains <span class="hljs-number">4</span> <span class="hljs-meta">sets</span> of Vec4, so <span class="hljs-number">4</span> * <span class="hljs-number">16</span> <span class="hljs-keyword">Bytes
</span>
<span class="hljs-symbol">For</span> EXAMPLE
<span class="hljs-symbol">Float</span> - Float - Vec3 - Float

<span class="hljs-symbol">FF00</span> VVVV F000

<span class="hljs-symbol">You</span> also can<span class="hljs-string">'t straddle byte boundries. So if you'</span>re trying to pack this: Float-Vec2
<span class="hljs-symbol">This</span> is valid: F0VV
<span class="hljs-keyword">But </span>this isn<span class="hljs-string">'t: FVV0
</span></code></pre>
<script type="text/javascript" src="shader-overview.md.js" defer></script>
<script type="text/javascript" src="mdoc.js" defer></script>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/uicomponents/radio-button"><span class="arrow-prev">← </span><span>Radio Button</span></a><a class="docs-next button" href="/docs/shaders/constants"><span>Shader Constants, Variables, and Outputs</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-is-a-shader">What is a shader?</a></li><li><a href="#aim-of-the-shader-docs">Aim of the shader docs</a></li><li><a href="#how-to-get-started-with-shaders">How to get started with Shaders</a></li><li><a href="#entity-vs-blend-shaders">Entity vs Blend Shaders</a><ul class="toc-headings"><li><a href="#functions-available-for-override">Functions available for override</a></li><li><a href="#constants-and-variables">Constants and variables</a></li></ul></li><li><a href="#loading-external-shader-files">Loading external shader files</a></li><li><a href="#using-shaders-in-your-scene">Using shaders in your scene</a></li><li><a href="#providing-data-to-your-shaders">Providing data to your shaders</a></li><li><a href="#uniformblock--ubo-data-packing-rules"><code>UniformBlock</code> / UBO Data Packing Rules</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a><a href="/docs/en/quickstart/project-templates">Project templates</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://github.com/PurpleKingdomGames/indigo/discussions">GitHub Discussons</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section></footer></div></body></html>