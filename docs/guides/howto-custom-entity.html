<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>How to make a custom entity · Indigo</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## What are custom entities?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="How to make a custom entity · Indigo"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="## What are custom entities?"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/indigo_logo_solid.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="Indigo Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="Indigo Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-169190516-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-169190516-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/indigo_logo_solid_text.svg" alt="Indigo"/><h2 class="headerTitleWithLogo">Indigo</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="siteNavGroupActive"><a href="/docs/guides" target="_self">Guides</a></li><li class=""><a href="/docs/development-status" target="_self">Docs</a></li><li class=""><a href="/api/" target="_self">APIs</a></li><li class=""><a href="/tools" target="_self">Tools</a></li><li class=""><a href="https://github.com/PurpleKingdomGames/indigo" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Gamedev</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">How To&#x27;s</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/guides">About these guides</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gamedev</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/guides/howto-custom-entity">How to make a custom entity</a></li><li class="navListItem"><a class="navItem" href="/docs/guides/howto-fire-shader">How to write a fire shader</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">How to make a custom entity</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="what-are-custom-entities"></a><a href="#what-are-custom-entities" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are custom entities?</h2>
<p>Indigo comes with a range of primitive entity types such as <code>Graphic</code>s and <code>Sprite</code>s.</p>
<p>You can do a lot with a standard primitive, but sometimes you might like to create a visual effect that can't be expressed easily or perhaps efficiently using something out of the box.</p>
<p>That is where custom entities come in, they allow you to create pretty much anything you like. You are limited by what the interface requires and your ability to program against it.</p>
<h2><a class="anchor" aria-hidden="true" id="custom-entities-and-built-in-primitives"></a><a href="#custom-entities-and-built-in-primitives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom entities and built in primitives</h2>
<p>A brief word on the relationship between custom entities and primitive types.</p>
<p>Primitive types have an advantage over custom entities in that the engine understands them, and can perform optimisations and special cased routines to help process them.</p>
<p>An example of this is the <code>Group</code> type. A custom entity is required to provide a size which tells Indigo how much space it will take up on the screen, however a group’s size is determined by the position and dimensions of it's children and this is calculated in the engine during the scene processing phase, indeed there is also special case code that manages the <em>un-grouping</em> of groups in order to produce a flat list of renderable items.</p>
<p>This sort of processing can't be achieved using custom entities because the engine does not understand them in the same way.</p>
<p>Having said that, new primitive types often start life as a new custom <code>EntityNode</code> because they are really very powerful things.</p>
<h2><a class="anchor" aria-hidden="true" id="making-a-custom-entity"></a><a href="#making-a-custom-entity" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making a custom entity</h2>
<p>Our goal is to make two simple custom entities, one that is a solid color, and the other than draws a texture. The shaders we write will be very very simple, more complex shaders are out of the scope of this guide.</p>
<p>If you'd like to skip ahead, you can see the end result <a href="https://github.com/PurpleKingdomGames/indigo-examples/tree/master/howto/custom-entity">in the custom entity example repo</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="the-basics"></a><a href="#the-basics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The basics</h3>
<p>When you get right down to it, Indigo needs to know two things about anything it's going to draw:</p>
<ol>
<li>The area of the screen that will be drawn into.</li>
<li>What to draw in that space.</li>
</ol>
<p>These are handled by providing some spatial parameters that Indigo will interpret, and a shader program, respectively.</p>
<p>Here is the interface we have to satisfy for a hypothetical custom entity called <code>MyCustomEntity</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> indigo._

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomEntity</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">EntityNode</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">position</span></span>: <span class="hljs-type">Point</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span></span>: <span class="hljs-type">Size</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth</span></span>: <span class="hljs-type">Depth</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flip</span></span>: <span class="hljs-type">Flip</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ref</span></span>: <span class="hljs-type">Point</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotation</span></span>: <span class="hljs-type">Radians</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale</span></span>: <span class="hljs-type">Vector2</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withDepth</span></span>(newDepth: <span class="hljs-type">Depth</span>): <span class="hljs-type">MyCustomEntity</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toShaderData</span></span>: <span class="hljs-type">ShaderData</span> = ???
</code></pre>
<p>Case classes work well, but anything that <em>is a</em> <code>EntityNode</code> will be fine.</p>
<p>Most of the fields are to do with allocating space on the screen, but unlike built-in primitives, you are not required to add all the usual modifiers - whether you want them or not is up to you.</p>
<p>The <code>toShaderData</code> definition is the part that tells Indigo how to draw the entity.</p>
<h3><a class="anchor" aria-hidden="true" id="filling-the-space-with-color"></a><a href="#filling-the-space-with-color" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filling the space with color</h3>
<p>Here is a modified version of the code above that fills it's area with green.</p>
<pre><code class="hljs css language-scala">final case class MyColoredEntity(position: Point, depth: Depth) extends EntityNode:
  def size: Size        = Size(32, 32)
  def flip: Flip        = Flip.default
  def ref: Point        = Point.zero
  def rotation: Radians = Radians.zero
  def scale: Vector2    = Vector2.one

  def withDepth(newDepth: Depth): MyColoredEntity =
    this.copy(depth = newDepth)

  def toShaderData: ShaderData =
    ShaderData(MyColoredEntity.shader.id)

object MyColoredEntity:
  val shader: EntityShader =
    EntityShader
      .Source(ShaderId("my-colored-shader"))
      .withFragmentProgram(
        """
        |void fragment() {
        |  COLOR = vec4(0.0, 1.0, 0.0, 1.0);
        |}
        |""".stripMargin
      )
</code></pre>
<p>Walking through it, <code>position</code> and <code>depth</code> have been moved to be case class arguments. The other members have been given appropriate default values, e.g. you can't rotate this because there's no way to set rotation, and <code>withDepth</code> has been implemented as a simple case class copy operation.</p>
<p>Then things get a little more complicated. <code>toShaderData</code> has been implemented by creating a <code>ShaderData</code> instance that only takes a <code>ShaderId</code>, which it sources from the companion object.</p>
<p>The companion object defines the shader that is going to color in our entity by declaring an <code>EntityShader</code> (as opposed to a <code>BlendShader</code>). <code>Shader</code> instances whether a <code>BlendShader</code> or an <code>EntityShader</code> come in two forms: <code>EnityShader.Source(..)</code> or <code>EnityShader.External(..)</code>. The difference is that <code>Source</code> instances literally take the GLSL program as a <code>String</code>, and <code>External</code> instances look for loaded assets, which is a much nicer editing experience.</p>
<p>There are several parts to an Indigo shader program that can be set (or default implementations are used), but in this case we're only setting the fragment program as follows:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</code></pre>
<p><img src="/img/howtos/green-square.png" alt="Shader filling a square green" title="Shader filling a square green"></p>
<p>This tells the GPU to set the <code>COLOR</code> output variable to a <code>vec4</code> that denotes the RGBA color of the pixel with values ranging from <code>0.0f</code> to <code>1.0f</code>. Here we're setting full green and full alpha (opaque).</p>
<p>To use this shiny new entity, we have to do two things:</p>
<p>First, tell indigo about the new shader:</p>
<p>In the sandbox this would be a game field just like assets and fonts, i.e. <code>val shaders: Set[Shader] = Set(MyColoredEntity.shader)</code>, and there is an equivalent for the <code>BootResult</code> type as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boot</span></span>(flags: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">String</span>]): <span class="hljs-type">Outcome</span>[<span class="hljs-type">BootResult</span>[<span class="hljs-type">Unit</span>]] =
  <span class="hljs-type">Outcome</span>(
    <span class="hljs-type">BootResult</span>
      .noData(<span class="hljs-type">GameConfig</span>.<span class="hljs-keyword">default</span>)
      .withShaders(<span class="hljs-type">MyColoredEntity</span>.shader)
  )
</code></pre>
<p>Next the fun bit, we need to add it to our scene, e.g.:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">present</span></span>(context: <span class="hljs-type">FrameContext</span>[<span class="hljs-type">Unit</span>], model: <span class="hljs-type">Unit</span>, viewModel: <span class="hljs-type">Unit</span>): <span class="hljs-type">Outcome</span>[<span class="hljs-type">SceneUpdateFragment</span>] =
  <span class="hljs-type">Outcome</span>(
    <span class="hljs-type">SceneUpdateFragment</span>(
      <span class="hljs-type">MyColoredEntity</span>(<span class="hljs-type">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>), <span class="hljs-type">Depth</span>(<span class="hljs-number">1</span>))
    )
  )
</code></pre>
<blockquote>
<p>If you wanted to set the color dynamically you'd need to send it to the shader via a <code>UniformBlock</code>, but that's out of scope for this tutorial.</p>
</blockquote>
<p>One more thing before we move on to textures. Indigo's shaders come with a series of variables and constants you can access, let's use one of them now by modifying our program as follows:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(UV.x, UV.y, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</code></pre>
<p><img src="/img/howtos/uv-square.png" alt="Shader filling a square using UVs for red and green" title="Shader filling a square using UVs for red and green"></p>
<p>The <code>UV</code> variable of type <code>vec2</code>, tells you the position of the pixel you are drawing as coordinates from <code>(0.0f, 0.0f)</code> in the top left to <code>(1.0f, 1.0f)</code> in the bottom right. So conveniently, we can illustrate this top-left to bottom-right transition by plugging the <code>UV.x</code> and <code>UV.y</code> fields in as our red and green values.</p>
<blockquote>
<p>Note that GLSL has a limited set of types and they all have quite flexible constructors, so you could also write the following which has the same meaning: <code>COLOR = vec4(UV, 0.0, 1.0);</code>, additionally access to fields like <code>.x</code> can be replaced with color indicators like <code>.r</code>,<code>.g</code>,<code>.b</code>, and <code>.a</code> - same value but makes more reading sense if your processing colors.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="using-textures"></a><a href="#using-textures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using textures</h3>
<p>Here is an almost identical entity to the last one and I won't repeat myself, but remember to:</p>
<ol>
<li>Tell indigo about the shader (as above), note that shader id's must be unique.</li>
<li>Add the entity to the scene</li>
<li>Tell indigo to load the asset using the normal asset loading process.</li>
</ol>
<pre><code class="hljs css language-scala">final case class MyBitmapEntity(asset: AssetName, position: Point, depth: Depth) extends EntityNode:
  def size: Size        = Size(32, 32)
  def flip: Flip        = Flip.default
  def ref: Point        = Point.zero
  def rotation: Radians = Radians.zero
  def scale: Vector2    = Vector2.one

  def withDepth(newDepth: Depth): MyBitmapEntity =
    this.copy(depth = newDepth)

  def toShaderData: ShaderData =
    ShaderData(MyBitmapEntity.shader.id)
      .withChannel0(asset)

object MyBitmapEntity:
  val shader: EntityShader =
    EntityShader
      .Source(ShaderId("my-bitmap-shader"))
      .withFragmentProgram(
        """
        |void fragment() {
        |  COLOR = CHANNEL_0;
        |}
        |""".stripMargin
      )
</code></pre>
<p>The difference between this one and the last one is that we're telling Indigo to use a texture by assigning it to a channel and referring to it in the shader program.</p>
<blockquote>
<p><strong>Important:</strong> Textures aren't quite as straightforward as they seem, a key piece of information is that when you load textures, Indigo attempts to compile them into 4k texture atlases, which reduces context switching. Currently, Indigo is <em>limited</em> to only loading one atlas at a time, so although a <code>ShaderData</code> instance allows you to set four channels with different <code>AssetName</code>s, they must all be on the same atlas. For small games you don't need to worry, but if you have large assets you can force Indigo to place related images onto the same atlas using <code>AssetType.Tagged(&quot;my tag&quot;)(image1..imageN)</code> in your asset list.</p>
</blockquote>
<p>The shader data has the asset name given to channel 0, and in the fragment shader we set the <code>COLOR</code> output to the color value sampled from the texture, which is set to a variable called <code>CHANNEL_0</code>, which is a <code>vec4</code>. If we wanted to, we could only draw the red component of the texture by doing the following:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> fragment() {
  COLOR = <span class="hljs-type">vec4</span>(CHANNEL_0.r, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, CHANNEL_0.a);
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="wrapping-up"></a><a href="#wrapping-up" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping up</h2>
<p>I hope that's given you a small taste of the power of writing custom entities, and a starting point for you to begin creating your own. Much of the heavy lifting is done by writing shaders which we haven't gone too far into here, but if you need some shader inspiration I'd recommend heading over to <a href="https://www.shadertoy.com/">shadertoy</a> for a browse.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/guides"><span class="arrow-prev">← </span><span>About these guides</span></a><a class="docs-next button" href="/docs/guides/howto-fire-shader"><span>How to write a fire shader</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-are-custom-entities">What are custom entities?</a></li><li><a href="#custom-entities-and-built-in-primitives">Custom entities and built in primitives</a></li><li><a href="#making-a-custom-entity">Making a custom entity</a><ul class="toc-headings"><li><a href="#the-basics">The basics</a></li><li><a href="#filling-the-space-with-color">Filling the space with color</a></li><li><a href="#using-textures">Using textures</a></li></ul></li><li><a href="#wrapping-up">Wrapping up</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/indigo_logo.svg" alt="Indigo" width="66" height="58"/></a><div><h5>Getting Started</h5><a href="/docs/en/quickstart/setup-and-configuration">Setup &amp; Configuration Guide</a><a href="/docs/en/quickstart/hello-indigo">&quot;Hello, Indigo!&quot; Tutorial</a><a href="/docs/en/quickstart/examples">Links to examples</a><a href="/docs/en/quickstart/project-templates">Project templates</a></div><div><h5>Community</h5><a href="https://discord.gg/b5CD47g">Discord</a><a href="https://github.com/PurpleKingdomGames/indigo/discussions">GitHub Discussons</a><a href="https://twitter.com/indigoengine" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>Sponsor us!</h5><a href="https://github.com/sponsors/PurpleKingdomGames">GitHub Sponsors</a><a href="https://www.patreon.com/indigoengine">Patreon</a></div></section></footer></div></body></html>